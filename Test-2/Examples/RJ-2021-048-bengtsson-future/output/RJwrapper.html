<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/>
  <meta name="generator" content="distill" />

  <style type="text/css">
  /* Hide doc at startup (prevent jankiness while JS renders/transforms) */
  body {
    visibility: hidden;
  }
  </style>

 <!--radix_placeholder_import_source-->
 <!--/radix_placeholder_import_source-->

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ad0000; } /* Alert */
code span.an { color: #5e5e5e; } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #ad0000; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007ba5; } /* ControlFlow */
code span.ch { color: #20794d; } /* Char */
code span.cn { color: #8f5902; } /* Constant */
code span.co { color: #5e5e5e; } /* Comment */
code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
code span.dt { color: #ad0000; } /* DataType */
code span.dv { color: #ad0000; } /* DecVal */
code span.er { color: #ad0000; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #ad0000; } /* Float */
code span.fu { color: #4758ab; } /* Function */
code span.im { } /* Import */
code span.in { color: #5e5e5e; } /* Information */
code span.kw { color: #007ba5; } /* Keyword */
code span.op { color: #5e5e5e; } /* Operator */
code span.ot { color: #007ba5; } /* Other */
code span.pp { color: #ad0000; } /* Preprocessor */
code span.sc { color: #5e5e5e; } /* SpecialChar */
code span.ss { color: #20794d; } /* SpecialString */
code span.st { color: #20794d; } /* String */
code span.va { color: #111111; } /* Variable */
code span.vs { color: #20794d; } /* VerbatimString */
code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
</style>

<style>
  div.csl-bib-body { }
  div.csl-entry {
    clear: both;
    }
  .hanging div.csl-entry {
    margin-left:2em;
    text-indent:-2em;
  }
  div.csl-left-margin {
    min-width:2em;
    float:left;
  }
  div.csl-right-inline {
    margin-left:2em;
    padding-left:1em;
  }
  div.csl-indent {
    margin-left: 2em;
  }
</style>

  <!--radix_placeholder_meta_tags-->
  <title>A Unifying Framework for Parallel and Distributed Processing in R using Futures</title>

  <meta property="description" itemprop="description"/>

  <link rel="license" href="https://creativecommons.org/licenses/by/4.0/"/>


  <!--  https://developers.facebook.com/docs/sharing/webmasters#markup -->
  <meta property="og:title" content="A Unifying Framework for Parallel and Distributed Processing in R using Futures"/>
  <meta property="og:type" content="article"/>
  <meta property="og:description"/>
  <meta property="og:locale" content="en_US"/>

  <!--  https://dev.twitter.com/cards/types/summary -->
  <meta property="twitter:card" content="summary"/>
  <meta property="twitter:title" content="A Unifying Framework for Parallel and Distributed Processing in R using Futures"/>
  <meta property="twitter:description"/>

  <!--/radix_placeholder_meta_tags-->
  
  <meta name="citation_reference" content="citation_title=Mersenne twister: A 623-dimensionally equidistributed uniform pseudo-random number generator;citation_publication_date=1998;citation_author=M. Matsumoto;citation_author=T. Nishimura"/>
  <meta name="citation_reference" content="citation_title=Good parameters and implementations for combined multiple recursive random number generators;citation_publication_date=1999;citation_volume=47;citation_author=P. L’Ecuyer"/>
  <meta name="citation_reference" content="citation_title=doMC: Foreach parallel adaptor for ’parallel’;citation_publication_date=2020;citation_author=Steve Weston;citation_author=doMC: Foreach parallel adaptor for ’parallel’"/>
  <meta name="citation_reference" content="citation_title=doMPI: Foreach parallel adaptor for Rmpi package;citation_publication_date=2017;citation_author=Steve Weston"/>
  <meta name="citation_reference" content="citation_title=doParallel: Foreach parallel adaptor for the ’parallel’ package;citation_publication_date=2020;citation_author=Steve Weston;citation_author=doParallel: Foreach parallel adaptor for the ’parallel’ package"/>
  <meta name="citation_reference" content="citation_title=doRedis: ’Foreach’ parallel adapter using the ’redis’ database;citation_publication_date=2020;citation_author=B. W. Lewis"/>
  <meta name="citation_reference" content="citation_title=Foreach: Provides foreach looping construct;citation_publication_date=2020;citation_author=Steve Weston;citation_author=Foreach: Provides foreach looping construct"/>
  <meta name="citation_reference" content="citation_title=Future: Unified parallel and distributed processing in R for everyone;citation_publication_date=2021;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=Future.apply: Apply function to elements in parallel using futures;citation_publication_date=2021;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=doFuture: A universal foreach parallel adapter using the Future API of the ’future’ package;citation_publication_date=2021;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=Future.tests: Test suite for Future API backends;citation_publication_date=2021;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=Future.callr: A Future API for parallel processing using ’callr’;citation_publication_date=2021;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=Future.batchtools: A Future API for parallel and distributed processing using ’batchtools’;citation_publication_date=2021;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=Parallelly: Enhancing the ’parallel’ package;citation_publication_date=2021;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=Globals: Identify global objects in R expressions;citation_publication_date=2020;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=Listenv: Environments behaving (almost) as lists;citation_publication_date=2019;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=Digest: Create compact hash digests of R objects;citation_publication_date=2021;citation_author=Dirk Eddelbuettel;citation_author= Antoine Lucas;citation_author=Jarek Tuszynski;citation_author=Henrik Bengtsson;citation_author=Simon Urbanek;citation_author=Mario Frasca;citation_author=Bryan Lewis;citation_author=Murray Stokely;citation_author=Hannes Muehleisen;citation_author=Duncan Murdoch;citation_author=Jim Hester;citation_author=Wush Wu;citation_author=Qiang Kou;citation_author=Thierry Onkelinx;citation_author=Michel Lang;citation_author=Viliam Simko;citation_author=Kurt Hornik;citation_author=Radford Neal;citation_author=Kendon Bell;citation_author=Matthew Queljoe;citation_author=Ion Suruceanu;citation_author=Bill Denney."/>
  <meta name="citation_reference" content="citation_title=Progressr: A inclusive, unifying API for progress updates;citation_publication_date=2021;citation_author=Henrik Bengtsson"/>
  <meta name="citation_reference" content="citation_title=Codetools: Code analysis tools for R;citation_publication_date=2020;citation_author=Luke Tierney"/>
  <meta name="citation_reference" content="citation_title=Callr: Call R from R;citation_publication_date=2021;citation_author=Gábor Csárdi;citation_author=Winston Chang"/>
  <meta name="citation_reference" content="citation_title=googleComputeEngineR: R interface with Google Compute Engine;citation_publication_date=2019;citation_author=Mark Edmondson"/>
  <meta name="citation_reference" content="citation_title=Batchtools: Tools for R to work on batch systems;citation_publication_date=2017;citation_publisher=The Open Journal;citation_volume=2;citation_doi=10.21105/joss.00135;citation_author=Michel Lang;citation_author=Bernd Bischl;citation_author=Dirk Surmann"/>
  <meta name="citation_reference" content="citation_title=BatchJobs and BatchExperiments: Abstraction mechanisms for using R in batch environments;citation_publication_date=2015;citation_volume=64;citation_author=Bernd Bischl;citation_author=Michel Lang;citation_author=Olaf Mersmann;citation_author=Jörg Rahnenführer;citation_author=Claus Weihs"/>
  <meta name="citation_reference" content="citation_title=Promises: Abstractions for promise-based asynchronous programming;citation_publication_date=2021;citation_author=Joe Cheng"/>
  <meta name="citation_reference" content="citation_title=Shiny: Web application framework for R;citation_publication_date=2021;citation_author=Winston Chang;citation_author=Joe Cheng;citation_author=JJ Allaire;citation_author=Yihui Xie;citation_author=Jonathan McPherson"/>
  <meta name="citation_reference" content="citation_title=The drake R package: A pipeline toolkit for reproducibility and high-performance computing;citation_publication_date=2018;citation_volume=3;citation_author=William Michael Landau"/>
  <meta name="citation_reference" content="citation_title=Civis: R client for the ’civis platform API’;citation_publication_date=2020;citation_author=Patrick Miller;citation_author=Keith Ingersoll"/>
  <meta name="citation_reference" content="citation_title=BiocParallel: Bioconductor facilities for parallel evaluation;citation_publication_date=2021;citation_author=Martin Morgan;citation_author=Valerie Obenchain;citation_author=Michel Lang;citation_author=Ryan Thompson;citation_author=Nitesh Turaga"/>
  <meta name="citation_reference" content="citation_title=Furrr: Apply mapping functions in parallel using futures;citation_publication_date=2021;citation_author=Davis Vaughan;citation_author=Matt Dancho"/>
  <meta name="citation_reference" content="citation_title=Purrr: Functional programming tools;citation_publication_date=2020;citation_author=Lionel Henry;citation_author=Hadley Wickham"/>
  <meta name="citation_reference" content="citation_title=Aspects of applicative programming for parallel processing;citation_publication_date=1978;citation_publisher=Institute of Electrical; Electronics Engineers (IEEE);citation_volume=C-27;citation_doi=10.1109/tc.1978.1675100;citation_author=Daniel P. Friedman;citation_author=David S. Wise"/>
  <meta name="citation_reference" content="citation_title=Laws for communicating parallel processes;citation_publication_date=1977;citation_author=Carl Hewitt;citation_author=Henry G. Baker"/>
  <meta name="citation_reference" content="citation_title=Parallel processing facilities;citation_publication_date=1976;citation_publisher=IRIA;citation_author=Peter Hibbard"/>
  <meta name="citation_reference" content="citation_title=Snow: Simple network of workstations;citation_publication_date=2021;citation_author=Luke Tierney;citation_author=A. J. Rossini;citation_author=Na Li;citation_author=H. Sevcikova"/>
  <meta name="citation_reference" content="citation_title=Multicore: A stub package to ease transition to ’parallel’;citation_publication_date=2014;citation_author=Simon Urbanek"/>
  <meta name="citation_reference" content="citation_title=Revdepcheck: Automated reverse dependency checking;citation_publication_date=2021;citation_author=Gábor Csárdi;citation_author=Hadley Wickham"/>
  <meta name="citation_reference" content="citation_title=Singularity: Scientific containers for mobility of compute;citation_publication_date=2017;citation_publisher=Public Library of Science San Francisco, CA USA;citation_volume=12;citation_author=Gregory M Kurtzer;citation_author=Vanessa Sochat;citation_author=Michael W Bauer"/>
  <meta name="citation_reference" content="citation_title=Docker: Lightweight Linux containers for consistent development and deployment;citation_publication_date=2014;citation_volume=2014;citation_author=Dirk Merkel"/>
  <meta name="citation_reference" content="citation_title=MapReduce: Simplified data processing on large clusters;citation_publication_date=2004;citation_author=Jeffrey Dean;citation_author=Sanjay Ghemawat"/>
  <meta name="citation_reference" content="citation_title=Parallel computing with R: A brief review;citation_publication_date=2021;citation_volume=13;citation_doi=10.1002/wics.1515;citation_author=Dirk Eddelbuettel"/>
  <meta name="citation_reference" content="citation_title=Scalable strategies for computing with massive data;citation_publication_date=2013;citation_volume=55;citation_doi=10.18637/jss.v055.i14;citation_issn=1548-7660;citation_author=Michael Kane;citation_author=John Emerson;citation_author=Stephen Weston"/>
  <meta name="citation_reference" content="citation_title=State-of-the-art in parallel computing with r;citation_publication_date=2009;citation_volume=47;citation_author=Markus Schmidberger;citation_author=Martin Morgan;citation_author=Dirk Eddelbuettel;citation_author=Hao Yu;citation_author=Luke Tierney;citation_author=Ulrich Mansmann"/>
  <meta name="citation_reference" content="citation_title=Microbenchmark: Accurate timing functions;citation_publication_date=2021;citation_author=Olaf Mersmann"/>
  <meta name="citation_reference" content="citation_title=Bench: High precision timing of r expressions;citation_publication_date=2020;citation_author=Jim Hester"/>
  <meta name="citation_reference" content="citation_title=Proffer: Profile r code and visualize with ’pprof’;citation_publication_date=2021;citation_author=William Michael Landau"/>
  <meta name="citation_reference" content="citation_title=Profvis: Interactive visualizations for profiling r code;citation_publication_date=2020;citation_author=Winston Chang;citation_author=Javier Luraschi;citation_author=Timothy Mastny"/>
  <meta name="citation_reference" content="citation_title=Plumber: An API generator for r;citation_publication_date=2021;citation_author=Barret Schloerke;citation_author=Jeff Allen"/>
  <meta name="citation_reference" content="citation_title=Sparklyr: R interface to apache spark;citation_publication_date=2021;citation_author=Javier Luraschi;citation_author=Kevin Kuo;citation_author=Kevin Ushey;citation_author=JJ Allaire;citation_author=Hossein Falaki;citation_author=Lu Wang;citation_author=Andy Zhang;citation_author=Yitao Li;citation_author=Sparklyr: R interface to apache spark"/>
  <meta name="citation_reference" content="citation_title=Programming with BIG data in R: Scaling analytics from one to thousands of nodes;citation_publication_date=2017;citation_publisher=Elsevier;citation_volume=8;citation_doi=https://doi.org/10.1016/j.bdr.2016.10.002;citation_author=Drew Schmidt;citation_author=Wei-Chen Chen;citation_author=Michael A Matheson;citation_author=George Ostrouchov"/>
  <meta name="citation_reference" content="citation_title=The targets R package: A dynamic make-like function-oriented pipeline toolkit for reproducibility and high-performance computing;citation_publication_date=2021;citation_volume=6;citation_author=William Michael Landau"/>
  <!--radix_placeholder_rmarkdown_metadata-->

  <script type="text/json" id="radix-rmarkdown-metadata">
  {"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["title","bibliography","output","description","journal","slug","pdf_url","citation_url","doi","creative_commons","packages","CTV","csl"]}},"value":[{"type":"character","attributes":{},"value":["A Unifying Framework for Parallel and Distributed Processing in R using Futures"]},{"type":"character","attributes":{},"value":["bengtsson-future.bib"]},{"type":"character","attributes":{},"value":["rjtools::rjournal_web_article"]},{"type":"list","attributes":{},"value":[]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["title","issn","firstpage","lastpage"]}},"value":[{"type":"character","attributes":{},"value":["The R Journal"]},{"type":"character","attributes":{},"value":["2073-4859"]},{"type":"NULL"},{"type":"NULL"}]},{"type":"character","attributes":{},"value":["RJwrapper"]},{"type":"character","attributes":{},"value":["RJwrapper.pdf"]},{"type":"character","attributes":{},"value":["https://doi.org/10.32614/RJwrapper"]},{"type":"character","attributes":{},"value":["10.32614/RJwrapper"]},{"type":"character","attributes":{},"value":["CC BY"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["cran","bioc"]}},"value":[{"type":"list","attributes":{},"value":[]},{"type":"list","attributes":{},"value":[]}]},{"type":"list","attributes":{},"value":[]},{"type":"character","attributes":{},"value":["/home/abhi/R/x86_64-pc-linux-gnu-library/3.6/rjtools/rjournal.csl"]}]}
  </script>
  <!--/radix_placeholder_rmarkdown_metadata-->
  
  <script type="text/json" id="radix-resource-manifest">
  {"type":"character","attributes":{},"value":["bengtsson-future.bib","RJwrapper_files/anchor-4.2.2/anchor.min.js","RJwrapper_files/bowser-1.9.3/bowser.min.js","RJwrapper_files/distill-2.2.21/template.v2.js","RJwrapper_files/header-attrs-2.13/header-attrs.js","RJwrapper_files/jquery-3.6.0/jquery-3.6.0.js","RJwrapper_files/jquery-3.6.0/jquery-3.6.0.min.js","RJwrapper_files/jquery-3.6.0/jquery-3.6.0.min.map","RJwrapper_files/popper-2.6.0/popper.min.js","RJwrapper_files/tippy-6.2.7/tippy-bundle.umd.min.js","RJwrapper_files/tippy-6.2.7/tippy-light-border.css","RJwrapper_files/tippy-6.2.7/tippy.css","RJwrapper_files/tippy-6.2.7/tippy.umd.min.js","RJwrapper_files/webcomponents-2.0.0/webcomponents.js","RJwrapper.log","RJwrapper.tex"]}
  </script>
  <!--radix_placeholder_navigation_in_header-->
  <!--/radix_placeholder_navigation_in_header-->
  <!--radix_placeholder_distill-->

  <style type="text/css">

  body {
    background-color: white;
  }

  .pandoc-table {
    width: 100%;
  }

  .pandoc-table>caption {
    margin-bottom: 10px;
  }

  .pandoc-table th:not([align]) {
    text-align: left;
  }

  .pagedtable-footer {
    font-size: 15px;
  }

  d-byline .byline {
    grid-template-columns: 2fr 2fr;
  }

  d-byline .byline h3 {
    margin-block-start: 1.5em;
  }

  d-byline .byline .authors-affiliations h3 {
    margin-block-start: 0.5em;
  }

  .authors-affiliations .orcid-id {
    width: 16px;
    height:16px;
    margin-left: 4px;
    margin-right: 4px;
    vertical-align: middle;
    padding-bottom: 2px;
  }

  d-title .dt-tags {
    margin-top: 1em;
    grid-column: text;
  }

  .dt-tags .dt-tag {
    text-decoration: none;
    display: inline-block;
    color: rgba(0,0,0,0.6);
    padding: 0em 0.4em;
    margin-right: 0.5em;
    margin-bottom: 0.4em;
    font-size: 70%;
    border: 1px solid rgba(0,0,0,0.2);
    border-radius: 3px;
    text-transform: uppercase;
    font-weight: 500;
  }

  d-article table.gt_table td,
  d-article table.gt_table th {
    border-bottom: none;
  }

  .html-widget {
    margin-bottom: 2.0em;
  }

  .l-screen-inset {
    padding-right: 16px;
  }

  .l-screen .caption {
    margin-left: 10px;
  }

  .shaded {
    background: rgb(247, 247, 247);
    padding-top: 20px;
    padding-bottom: 20px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  }

  .shaded .html-widget {
    margin-bottom: 0;
    border: 1px solid rgba(0, 0, 0, 0.1);
  }

  .shaded .shaded-content {
    background: white;
  }

  .text-output {
    margin-top: 0;
    line-height: 1.5em;
  }

  .hidden {
    display: none !important;
  }

  d-article {
    padding-top: 2.5rem;
    padding-bottom: 30px;
  }

  d-appendix {
    padding-top: 30px;
  }

  d-article>p>img {
    width: 100%;
  }

  d-article h2 {
    margin: 1rem 0 1.5rem 0;
  }

  d-article h3 {
    margin-top: 1.5rem;
  }

  d-article iframe {
    border: 1px solid rgba(0, 0, 0, 0.1);
    margin-bottom: 2.0em;
    width: 100%;
  }

  /* Tweak code blocks */

  d-article div.sourceCode code,
  d-article pre code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  d-article pre,
  d-article div.sourceCode,
  d-article div.sourceCode pre {
    overflow: auto;
  }

  d-article div.sourceCode {
    background-color: white;
  }

  d-article div.sourceCode pre {
    padding-left: 10px;
    font-size: 12px;
    border-left: 2px solid rgba(0,0,0,0.1);
  }

  d-article pre {
    font-size: 12px;
    color: black;
    background: none;
    margin-top: 0;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  d-article pre a {
    border-bottom: none;
  }

  d-article pre a:hover {
    border-bottom: none;
    text-decoration: underline;
  }

  d-article details {
    grid-column: text;
    margin-bottom: 0.8em;
  }

  @media(min-width: 768px) {

  d-article pre,
  d-article div.sourceCode,
  d-article div.sourceCode pre {
    overflow: visible !important;
  }

  d-article div.sourceCode pre {
    padding-left: 18px;
    font-size: 14px;
  }

  d-article pre {
    font-size: 14px;
  }

  }

  figure img.external {
    background: white;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
    padding: 18px;
    box-sizing: border-box;
  }

  /* CSS for d-contents */

  .d-contents {
    grid-column: text;
    color: rgba(0,0,0,0.8);
    font-size: 0.9em;
    padding-bottom: 1em;
    margin-bottom: 1em;
    padding-bottom: 0.5em;
    margin-bottom: 1em;
    padding-left: 0.25em;
    justify-self: start;
  }

  @media(min-width: 1000px) {
    .d-contents.d-contents-float {
      height: 0;
      grid-column-start: 1;
      grid-column-end: 4;
      justify-self: center;
      padding-right: 3em;
      padding-left: 2em;
    }
  }

  .d-contents nav h3 {
    font-size: 18px;
    margin-top: 0;
    margin-bottom: 1em;
  }

  .d-contents li {
    list-style-type: none
  }

  .d-contents nav > ul {
    padding-left: 0;
  }

  .d-contents ul {
    padding-left: 1em
  }

  .d-contents nav ul li {
    margin-top: 0.6em;
    margin-bottom: 0.2em;
  }

  .d-contents nav a {
    font-size: 13px;
    border-bottom: none;
    text-decoration: none
    color: rgba(0, 0, 0, 0.8);
  }

  .d-contents nav a:hover {
    text-decoration: underline solid rgba(0, 0, 0, 0.6)
  }

  .d-contents nav > ul > li > a {
    font-weight: 600;
  }

  .d-contents nav > ul > li > ul {
    font-weight: inherit;
  }

  .d-contents nav > ul > li > ul > li {
    margin-top: 0.2em;
  }


  .d-contents nav ul {
    margin-top: 0;
    margin-bottom: 0.25em;
  }

  .d-article-with-toc h2:nth-child(2) {
    margin-top: 0;
  }


  /* Figure */

  .figure {
    position: relative;
    margin-bottom: 2.5em;
    margin-top: 1.5em;
  }

  .figure img {
    width: 100%;
  }

  .figure .caption {
    color: rgba(0, 0, 0, 0.6);
    font-size: 12px;
    line-height: 1.5em;
  }

  .figure img.external {
    background: white;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
    padding: 18px;
    box-sizing: border-box;
  }

  .figure .caption a {
    color: rgba(0, 0, 0, 0.6);
  }

  .figure .caption b,
  .figure .caption strong, {
    font-weight: 600;
    color: rgba(0, 0, 0, 1.0);
  }

  /* Citations */

  d-article .citation {
    color: inherit;
    cursor: inherit;
  }

  div.hanging-indent{
    margin-left: 1em; text-indent: -1em;
  }

  /* Citation hover box */

  .tippy-box[data-theme~=light-border] {
    background-color: rgba(250, 250, 250, 0.95);
  }

  .tippy-content > p {
    margin-bottom: 0;
    padding: 2px;
  }


  /* Tweak 1000px media break to show more text */

  @media(min-width: 1000px) {
    .base-grid,
    distill-header,
    d-title,
    d-abstract,
    d-article,
    d-appendix,
    distill-appendix,
    d-byline,
    d-footnote-list,
    d-citation-list,
    distill-footer {
      grid-template-columns: [screen-start] 1fr [page-start kicker-start] 80px [middle-start] 50px [text-start kicker-end] 65px 65px 65px 65px 65px 65px 65px 65px [text-end gutter-start] 65px [middle-end] 65px [page-end gutter-end] 1fr [screen-end];
      grid-column-gap: 16px;
    }

    .grid {
      grid-column-gap: 16px;
    }

    d-article {
      font-size: 1.06rem;
      line-height: 1.7em;
    }
    figure .caption, .figure .caption, figure figcaption {
      font-size: 13px;
    }
  }

  @media(min-width: 1180px) {
    .base-grid,
    distill-header,
    d-title,
    d-abstract,
    d-article,
    d-appendix,
    distill-appendix,
    d-byline,
    d-footnote-list,
    d-citation-list,
    distill-footer {
      grid-template-columns: [screen-start] 1fr [page-start kicker-start] 60px [middle-start] 60px [text-start kicker-end] 60px 60px 60px 60px 60px 60px 60px 60px [text-end gutter-start] 60px [middle-end] 60px [page-end gutter-end] 1fr [screen-end];
      grid-column-gap: 32px;
    }

    .grid {
      grid-column-gap: 32px;
    }
  }


  /* Get the citation styles for the appendix (not auto-injected on render since
     we do our own rendering of the citation appendix) */

  d-appendix .citation-appendix,
  .d-appendix .citation-appendix {
    font-size: 11px;
    line-height: 15px;
    border-left: 1px solid rgba(0, 0, 0, 0.1);
    padding-left: 18px;
    border: 1px solid rgba(0,0,0,0.1);
    background: rgba(0, 0, 0, 0.02);
    padding: 10px 18px;
    border-radius: 3px;
    color: rgba(150, 150, 150, 1);
    overflow: hidden;
    margin-top: -12px;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  /* Include appendix styles here so they can be overridden */

  d-appendix {
    contain: layout style;
    font-size: 0.8em;
    line-height: 1.7em;
    margin-top: 60px;
    margin-bottom: 0;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    color: rgba(0,0,0,0.5);
    padding-top: 60px;
    padding-bottom: 48px;
  }

  d-appendix h3 {
    grid-column: page-start / text-start;
    font-size: 15px;
    font-weight: 500;
    margin-top: 1em;
    margin-bottom: 0;
    color: rgba(0,0,0,0.65);
  }

  d-appendix h3 + * {
    margin-top: 1em;
  }

  d-appendix ol {
    padding: 0 0 0 15px;
  }

  @media (min-width: 768px) {
    d-appendix ol {
      padding: 0 0 0 30px;
      margin-left: -30px;
    }
  }

  d-appendix li {
    margin-bottom: 1em;
  }

  d-appendix a {
    color: rgba(0, 0, 0, 0.6);
  }

  d-appendix > * {
    grid-column: text;
  }

  d-appendix > d-footnote-list,
  d-appendix > d-citation-list,
  d-appendix > distill-appendix {
    grid-column: screen;
  }

  /* Include footnote styles here so they can be overridden */

  d-footnote-list {
    contain: layout style;
  }

  d-footnote-list > * {
    grid-column: text;
  }

  d-footnote-list a.footnote-backlink {
    color: rgba(0,0,0,0.3);
    padding-left: 0.5em;
  }



  /* Anchor.js */

  .anchorjs-link {
    /*transition: all .25s linear; */
    text-decoration: none;
    border-bottom: none;
  }
  *:hover > .anchorjs-link {
    margin-left: -1.125em !important;
    text-decoration: none;
    border-bottom: none;
  }

  /* Social footer */

  .social_footer {
    margin-top: 30px;
    margin-bottom: 0;
    color: rgba(0,0,0,0.67);
  }

  .disqus-comments {
    margin-right: 30px;
  }

  .disqus-comment-count {
    border-bottom: 1px solid rgba(0, 0, 0, 0.4);
    cursor: pointer;
  }

  #disqus_thread {
    margin-top: 30px;
  }

  .article-sharing a {
    border-bottom: none;
    margin-right: 8px;
  }

  .article-sharing a:hover {
    border-bottom: none;
  }

  .sidebar-section.subscribe {
    font-size: 12px;
    line-height: 1.6em;
  }

  .subscribe p {
    margin-bottom: 0.5em;
  }


  .article-footer .subscribe {
    font-size: 15px;
    margin-top: 45px;
  }


  .sidebar-section.custom {
    font-size: 12px;
    line-height: 1.6em;
  }

  .custom p {
    margin-bottom: 0.5em;
  }

  /* Styles for listing layout (hide title) */
  .layout-listing d-title, .layout-listing .d-title {
    display: none;
  }

  /* Styles for posts lists (not auto-injected) */


  .posts-with-sidebar {
    padding-left: 45px;
    padding-right: 45px;
  }

  .posts-list .description h2,
  .posts-list .description p {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
  }

  .posts-list .description h2 {
    font-weight: 700;
    border-bottom: none;
    padding-bottom: 0;
  }

  .posts-list h2.post-tag {
    border-bottom: 1px solid rgba(0, 0, 0, 0.2);
    padding-bottom: 12px;
  }
  .posts-list {
    margin-top: 60px;
    margin-bottom: 24px;
  }

  .posts-list .post-preview {
    text-decoration: none;
    overflow: hidden;
    display: block;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    padding: 24px 0;
  }

  .post-preview-last {
    border-bottom: none !important;
  }

  .posts-list .posts-list-caption {
    grid-column: screen;
    font-weight: 400;
  }

  .posts-list .post-preview h2 {
    margin: 0 0 6px 0;
    line-height: 1.2em;
    font-style: normal;
    font-size: 24px;
  }

  .posts-list .post-preview p {
    margin: 0 0 12px 0;
    line-height: 1.4em;
    font-size: 16px;
  }

  .posts-list .post-preview .thumbnail {
    box-sizing: border-box;
    margin-bottom: 24px;
    position: relative;
    max-width: 500px;
  }
  .posts-list .post-preview img {
    width: 100%;
    display: block;
  }

  .posts-list .metadata {
    font-size: 12px;
    line-height: 1.4em;
    margin-bottom: 18px;
  }

  .posts-list .metadata > * {
    display: inline-block;
  }

  .posts-list .metadata .publishedDate {
    margin-right: 2em;
  }

  .posts-list .metadata .dt-authors {
    display: block;
    margin-top: 0.3em;
    margin-right: 2em;
  }

  .posts-list .dt-tags {
    display: block;
    line-height: 1em;
  }

  .posts-list .dt-tags .dt-tag {
    display: inline-block;
    color: rgba(0,0,0,0.6);
    padding: 0.3em 0.4em;
    margin-right: 0.2em;
    margin-bottom: 0.4em;
    font-size: 60%;
    border: 1px solid rgba(0,0,0,0.2);
    border-radius: 3px;
    text-transform: uppercase;
    font-weight: 500;
  }

  .posts-list img {
    opacity: 1;
  }

  .posts-list img[data-src] {
    opacity: 0;
  }

  .posts-more {
    clear: both;
  }


  .posts-sidebar {
    font-size: 16px;
  }

  .posts-sidebar h3 {
    font-size: 16px;
    margin-top: 0;
    margin-bottom: 0.5em;
    font-weight: 400;
    text-transform: uppercase;
  }

  .sidebar-section {
    margin-bottom: 30px;
  }

  .categories ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }

  .categories li {
    color: rgba(0, 0, 0, 0.8);
    margin-bottom: 0;
  }

  .categories li>a {
    border-bottom: none;
  }

  .categories li>a:hover {
    border-bottom: 1px solid rgba(0, 0, 0, 0.4);
  }

  .categories .active {
    font-weight: 600;
  }

  .categories .category-count {
    color: rgba(0, 0, 0, 0.4);
  }


  @media(min-width: 768px) {
    .posts-list .post-preview h2 {
      font-size: 26px;
    }
    .posts-list .post-preview .thumbnail {
      float: right;
      width: 30%;
      margin-bottom: 0;
    }
    .posts-list .post-preview .description {
      float: left;
      width: 45%;
    }
    .posts-list .post-preview .metadata {
      float: left;
      width: 20%;
      margin-top: 8px;
    }
    .posts-list .post-preview p {
      margin: 0 0 12px 0;
      line-height: 1.5em;
      font-size: 16px;
    }
    .posts-with-sidebar .posts-list {
      float: left;
      width: 75%;
    }
    .posts-with-sidebar .posts-sidebar {
      float: right;
      width: 20%;
      margin-top: 60px;
      padding-top: 24px;
      padding-bottom: 24px;
    }
  }


  /* Improve display for browsers without grid (IE/Edge <= 15) */

  .downlevel {
    line-height: 1.6em;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
    margin: 0;
  }

  .downlevel .d-title {
    padding-top: 6rem;
    padding-bottom: 1.5rem;
  }

  .downlevel .d-title h1 {
    font-size: 50px;
    font-weight: 700;
    line-height: 1.1em;
    margin: 0 0 0.5rem;
  }

  .downlevel .d-title p {
    font-weight: 300;
    font-size: 1.2rem;
    line-height: 1.55em;
    margin-top: 0;
  }

  .downlevel .d-byline {
    padding-top: 0.8em;
    padding-bottom: 0.8em;
    font-size: 0.8rem;
    line-height: 1.8em;
  }

  .downlevel .section-separator {
    border: none;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
  }

  .downlevel .d-article {
    font-size: 1.06rem;
    line-height: 1.7em;
    padding-top: 1rem;
    padding-bottom: 2rem;
  }


  .downlevel .d-appendix {
    padding-left: 0;
    padding-right: 0;
    max-width: none;
    font-size: 0.8em;
    line-height: 1.7em;
    margin-bottom: 0;
    color: rgba(0,0,0,0.5);
    padding-top: 40px;
    padding-bottom: 48px;
  }

  .downlevel .footnotes ol {
    padding-left: 13px;
  }

  .downlevel .base-grid,
  .downlevel .distill-header,
  .downlevel .d-title,
  .downlevel .d-abstract,
  .downlevel .d-article,
  .downlevel .d-appendix,
  .downlevel .distill-appendix,
  .downlevel .d-byline,
  .downlevel .d-footnote-list,
  .downlevel .d-citation-list,
  .downlevel .distill-footer,
  .downlevel .appendix-bottom,
  .downlevel .posts-container {
    padding-left: 40px;
    padding-right: 40px;
  }

  @media(min-width: 768px) {
    .downlevel .base-grid,
    .downlevel .distill-header,
    .downlevel .d-title,
    .downlevel .d-abstract,
    .downlevel .d-article,
    .downlevel .d-appendix,
    .downlevel .distill-appendix,
    .downlevel .d-byline,
    .downlevel .d-footnote-list,
    .downlevel .d-citation-list,
    .downlevel .distill-footer,
    .downlevel .appendix-bottom,
    .downlevel .posts-container {
    padding-left: 150px;
    padding-right: 150px;
    max-width: 900px;
  }
  }

  .downlevel pre code {
    display: block;
    border-left: 2px solid rgba(0, 0, 0, .1);
    padding: 0 0 0 20px;
    font-size: 14px;
  }

  .downlevel code, .downlevel pre {
    color: black;
    background: none;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  .downlevel .posts-list .post-preview {
    color: inherit;
  }



  </style>

  <script type="application/javascript">

  function is_downlevel_browser() {
    if (bowser.isUnsupportedBrowser({ msie: "12", msedge: "16"},
                                   window.navigator.userAgent)) {
      return true;
    } else {
      return window.load_distill_framework === undefined;
    }
  }

  // show body when load is complete
  function on_load_complete() {

    // add anchors
    if (window.anchors) {
      window.anchors.options.placement = 'left';
      window.anchors.add('d-article > h2, d-article > h3, d-article > h4, d-article > h5');
    }


    // set body to visible
    document.body.style.visibility = 'visible';

    // force redraw for leaflet widgets
    if (window.HTMLWidgets) {
      var maps = window.HTMLWidgets.findAll(".leaflet");
      $.each(maps, function(i, el) {
        var map = this.getMap();
        map.invalidateSize();
        map.eachLayer(function(layer) {
          if (layer instanceof L.TileLayer)
            layer.redraw();
        });
      });
    }

    // trigger 'shown' so htmlwidgets resize
    $('d-article').trigger('shown');
  }

  function init_distill() {

    init_common();

    // create front matter
    var front_matter = $('<d-front-matter></d-front-matter>');
    $('#distill-front-matter').wrap(front_matter);

    // create d-title
    $('.d-title').changeElementType('d-title');

    // create d-byline
    var byline = $('<d-byline></d-byline>');
    $('.d-byline').replaceWith(byline);

    // create d-article
    var article = $('<d-article></d-article>');
    $('.d-article').wrap(article).children().unwrap();

    // move posts container into article
    $('.posts-container').appendTo($('d-article'));

    // create d-appendix
    $('.d-appendix').changeElementType('d-appendix');

    // flag indicating that we have appendix items
    var appendix = $('.appendix-bottom').children('h3').length > 0;

    // replace footnotes with <d-footnote>
    $('.footnote-ref').each(function(i, val) {
      appendix = true;
      var href = $(this).attr('href');
      var id = href.replace('#', '');
      var fn = $('#' + id);
      var fn_p = $('#' + id + '>p');
      fn_p.find('.footnote-back').remove();
      var text = fn_p.html();
      var dtfn = $('<d-footnote></d-footnote>');
      dtfn.html(text);
      $(this).replaceWith(dtfn);
    });
    // remove footnotes
    $('.footnotes').remove();

    // move refs into #references-listing
    $('#references-listing').replaceWith($('#refs'));

    $('h1.appendix, h2.appendix').each(function(i, val) {
      $(this).changeElementType('h3');
    });
    $('h3.appendix').each(function(i, val) {
      var id = $(this).attr('id');
      $('.d-contents a[href="#' + id + '"]').parent().remove();
      appendix = true;
      $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('d-appendix'));
    });

    // show d-appendix if we have appendix content
    $("d-appendix").css('display', appendix ? 'grid' : 'none');

    // localize layout chunks to just output
    $('.layout-chunk').each(function(i, val) {

      // capture layout
      var layout = $(this).attr('data-layout');

      // apply layout to markdown level block elements
      var elements = $(this).children().not('details, div.sourceCode, pre, script');
      elements.each(function(i, el) {
        var layout_div = $('<div class="' + layout + '"></div>');
        if (layout_div.hasClass('shaded')) {
          var shaded_content = $('<div class="shaded-content"></div>');
          $(this).wrap(shaded_content);
          $(this).parent().wrap(layout_div);
        } else {
          $(this).wrap(layout_div);
        }
      });


      // unwrap the layout-chunk div
      $(this).children().unwrap();
    });

    // remove code block used to force  highlighting css
    $('.distill-force-highlighting-css').parent().remove();

    // remove empty line numbers inserted by pandoc when using a
    // custom syntax highlighting theme
    $('code.sourceCode a:empty').remove();

    // load distill framework
    load_distill_framework();

    // wait for window.distillRunlevel == 4 to do post processing
    function distill_post_process() {

      if (!window.distillRunlevel || window.distillRunlevel < 4)
        return;

      // hide author/affiliations entirely if we have no authors
      var front_matter = JSON.parse($("#distill-front-matter").html());
      var have_authors = front_matter.authors && front_matter.authors.length > 0;
      if (!have_authors)
        $('d-byline').addClass('hidden');

      // article with toc class
      $('.d-contents').parent().addClass('d-article-with-toc');

      // strip links that point to #
      $('.authors-affiliations').find('a[href="#"]').removeAttr('href');

      // add orcid ids
      $('.authors-affiliations').find('.author').each(function(i, el) {
        var orcid_id = front_matter.authors[i].orcidID;
        if (orcid_id) {
          var a = $('<a></a>');
          a.attr('href', 'https://orcid.org/' + orcid_id);
          var img = $('<img></img>');
          img.addClass('orcid-id');
          img.attr('alt', 'ORCID ID');
          img.attr('src','data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg==');
          a.append(img);
          $(this).append(a);
        }
      });

      // hide elements of author/affiliations grid that have no value
      function hide_byline_column(caption) {
        $('d-byline').find('h3:contains("' + caption + '")').parent().css('visibility', 'hidden');
      }

      // affiliations
      var have_affiliations = false;
      for (var i = 0; i<front_matter.authors.length; ++i) {
        var author = front_matter.authors[i];
        if (author.affiliation !== "&nbsp;") {
          have_affiliations = true;
          break;
        }
      }
      if (!have_affiliations)
        $('d-byline').find('h3:contains("Affiliations")').css('visibility', 'hidden');

      // published date
      if (!front_matter.publishedDate)
        hide_byline_column("Published");

      // document object identifier
      var doi = $('d-byline').find('h3:contains("DOI")');
      var doi_p = doi.next().empty();
      if (!front_matter.doi) {
        // if we have a citation and valid citationText then link to that
        if ($('#citation').length > 0 && front_matter.citationText) {
          doi.html('Citation');
          $('<a href="#citation"></a>')
            .text(front_matter.citationText)
            .appendTo(doi_p);
        } else {
          hide_byline_column("DOI");
        }
      } else {
        $('<a></a>')
           .attr('href', "https://doi.org/" + front_matter.doi)
           .html(front_matter.doi)
           .appendTo(doi_p);
      }

       // change plural form of authors/affiliations
      if (front_matter.authors.length === 1) {
        var grid = $('.authors-affiliations');
        grid.children('h3:contains("Authors")').text('Author');
        grid.children('h3:contains("Affiliations")').text('Affiliation');
      }

      // remove d-appendix and d-footnote-list local styles
      $('d-appendix > style:first-child').remove();
      $('d-footnote-list > style:first-child').remove();

      // move appendix-bottom entries to the bottom
      $('.appendix-bottom').appendTo('d-appendix').children().unwrap();
      $('.appendix-bottom').remove();

      // hoverable references
      $('span.citation[data-cites]').each(function() {
        var refs = $(this).attr('data-cites').split(" ");
        var refHtml = refs.map(function(ref) {
          return "<p>" + $('#ref-' + ref).html() + "</p>";
        }).join("\n");
        window.tippy(this, {
          allowHTML: true,
          content: refHtml,
          maxWidth: 500,
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start'
        });
      });

      // clear polling timer
      clearInterval(tid);

      // show body now that everything is ready
      on_load_complete();
    }

    var tid = setInterval(distill_post_process, 50);
    distill_post_process();

  }

  function init_downlevel() {

    init_common();

     // insert hr after d-title
    $('.d-title').after($('<hr class="section-separator"/>'));

    // check if we have authors
    var front_matter = JSON.parse($("#distill-front-matter").html());
    var have_authors = front_matter.authors && front_matter.authors.length > 0;

    // manage byline/border
    if (!have_authors)
      $('.d-byline').remove();
    $('.d-byline').after($('<hr class="section-separator"/>'));
    $('.d-byline a').remove();

    // remove toc
    $('.d-contents').remove();

    // move appendix elements
    $('h1.appendix, h2.appendix').each(function(i, val) {
      $(this).changeElementType('h3');
    });
    $('h3.appendix').each(function(i, val) {
      $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('.d-appendix'));
    });


    // inject headers into references and footnotes
    var refs_header = $('<h3></h3>');
    refs_header.text('References');
    $('#refs').prepend(refs_header);

    var footnotes_header = $('<h3></h3');
    footnotes_header.text('Footnotes');
    $('.footnotes').children('hr').first().replaceWith(footnotes_header);

    // move appendix-bottom entries to the bottom
    $('.appendix-bottom').appendTo('.d-appendix').children().unwrap();
    $('.appendix-bottom').remove();

    // remove appendix if it's empty
    if ($('.d-appendix').children().length === 0)
      $('.d-appendix').remove();

    // prepend separator above appendix
    $('.d-appendix').before($('<hr class="section-separator" style="clear: both"/>'));

    // trim code
    $('pre>code').each(function(i, val) {
      $(this).html($.trim($(this).html()));
    });

    // move posts-container right before article
    $('.posts-container').insertBefore($('.d-article'));

    $('body').addClass('downlevel');

    on_load_complete();
  }


  function init_common() {

    // jquery plugin to change element types
    (function($) {
      $.fn.changeElementType = function(newType) {
        var attrs = {};

        $.each(this[0].attributes, function(idx, attr) {
          attrs[attr.nodeName] = attr.nodeValue;
        });

        this.replaceWith(function() {
          return $("<" + newType + "/>", attrs).append($(this).contents());
        });
      };
    })(jQuery);

    // prevent underline for linked images
    $('a > img').parent().css({'border-bottom' : 'none'});

    // mark non-body figures created by knitr chunks as 100% width
    $('.layout-chunk').each(function(i, val) {
      var figures = $(this).find('img, .html-widget');
      if ($(this).attr('data-layout') !== "l-body") {
        figures.css('width', '100%');
      } else {
        figures.css('max-width', '100%');
        figures.filter("[width]").each(function(i, val) {
          var fig = $(this);
          fig.css('width', fig.attr('width') + 'px');
        });

      }
    });

    // auto-append index.html to post-preview links in file: protocol
    // and in rstudio ide preview
    $('.post-preview').each(function(i, val) {
      if (window.location.protocol === "file:")
        $(this).attr('href', $(this).attr('href') + "index.html");
    });

    // get rid of index.html references in header
    if (window.location.protocol !== "file:") {
      $('.distill-site-header a[href]').each(function(i,val) {
        $(this).attr('href', $(this).attr('href').replace("index.html", "./"));
      });
    }

    // add class to pandoc style tables
    $('tr.header').parent('thead').parent('table').addClass('pandoc-table');
    $('.kable-table').children('table').addClass('pandoc-table');

    // add figcaption style to table captions
    $('caption').parent('table').addClass("figcaption");

    // initialize posts list
    if (window.init_posts_list)
      window.init_posts_list();

    // implmement disqus comment link
    $('.disqus-comment-count').click(function() {
      window.headroom_prevent_pin = true;
      $('#disqus_thread').toggleClass('hidden');
      if (!$('#disqus_thread').hasClass('hidden')) {
        var offset = $(this).offset();
        $(window).resize();
        $('html, body').animate({
          scrollTop: offset.top - 35
        });
      }
    });
  }

  document.addEventListener('DOMContentLoaded', function() {
    if (is_downlevel_browser())
      init_downlevel();
    else
      window.addEventListener('WebComponentsReady', init_distill);
  });

  </script>

  <!--/radix_placeholder_distill-->
  <script src="RJwrapper_files/header-attrs-2.13/header-attrs.js"></script>
  <script src="RJwrapper_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
  <script src="RJwrapper_files/popper-2.6.0/popper.min.js"></script>
  <link href="RJwrapper_files/tippy-6.2.7/tippy.css" rel="stylesheet" />
  <link href="RJwrapper_files/tippy-6.2.7/tippy-light-border.css" rel="stylesheet" />
  <script src="RJwrapper_files/tippy-6.2.7/tippy.umd.min.js"></script>
  <script src="RJwrapper_files/anchor-4.2.2/anchor.min.js"></script>
  <script src="RJwrapper_files/bowser-1.9.3/bowser.min.js"></script>
  <script src="RJwrapper_files/webcomponents-2.0.0/webcomponents.js"></script>
  <script src="RJwrapper_files/distill-2.2.21/template.v2.js"></script>
  <!--radix_placeholder_site_in_header-->
  <!--/radix_placeholder_site_in_header-->
  <script>
    $(function() {
      console.log("Starting...")

      // Always show Published - distill hides it if not set
      function show_byline_column(caption) {
        $('d-byline').find('h3:contains("' + caption + '")').parent().css('visibility', 'visible');
      }

      show_byline_column('Published')

      // tweak function
      var rmd_meta = JSON.parse($("#radix-rmarkdown-metadata").html());
      function get_meta(name, meta) {
        var ind = meta.attributes.names.value.findIndex((e) => e == name)
        var val = meta.value[ind]
        if (val.type != 'list') {
          return val.value.toString()
        }
        return val
      }

      // tweak description
      // Add clickable tags
      const slug = get_meta('slug', rmd_meta)
      const doi = get_meta('doi', rmd_meta)

      var title = $("d-title").text

      const buttons = $('<div class="dt-tags" style="grid-column: page;">')
      buttons.append('<a href="#citation" class="dt-tag"><i class="fas fa-quote-left"></i> Cite</a>')
      buttons.append('<a href="' + slug + '.pdf" class="dt-tag"><i class="fas fa-file-pdf"></i> PDF</a>')
      buttons.append('<a href="https://twitter.com/intent/tweet?text='+title+'&url=https%3A%2F%2Fdoi.org%2F' + doi + '" class="dt-tag"><i class="fab fa-twitter"></i> Tweet</a>')

      const abstract = $('<d-abstract>')
      abstract.append('<b>Abstract:</b><br>')
      abstract.append($("d-title p:not(:empty)").first()) // Move description to d-abstract
      $("d-title p:empty").remove() // Remove empty paragraphs after title
      abstract.append(buttons)
      abstract.insertAfter($('d-title')) // Add abstract section after title

      // tweak by-line
      var byline = $("d-byline div.byline")
      ind = rmd_meta.attributes.names.value.findIndex((e) => e == "journal")
      const journal = get_meta('journal', rmd_meta)
      const volume = get_meta('volume', rmd_meta)
      const issue = get_meta('issue', rmd_meta)
      const jrtitle = get_meta('title', journal)
      const firstpage = get_meta('firstpage', journal)
      const lastpage = get_meta('lastpage', journal)
      byline.append('<div class="rjournal grid">')
      $('div.rjournal').append('<h3>Volume</h3>')
      $('div.rjournal').append('<h3>Pages</h3>')
      $('div.rjournal').append('<p class="volume">'+volume+':'+issue+'</p>')
      $('div.rjournal').append('<p class="pages">'+firstpage+' - '+lastpage+'</p>')

      const received_date = new Date(get_meta('date_received', rmd_meta))
      byline.find('h3:contains("Published")').parent().append('<h3>Received</h3><p>'+received_date.toLocaleDateString('en-US', {month: 'short'})+' '+received_date.getDate()+', '+received_date.getFullYear()+'</p>')

    })
  </script>

  <style>
      /*
    .nav-dropdown-content .nav-dropdown-header {
      text-transform: lowercase;
    }
    */

    d-byline .byline {
      grid-template-columns: 2fr 2fr 2fr 2fr;
    }

    d-byline .rjournal {
      grid-column-end: span 2;
      grid-template-columns: 1fr 1fr;
      margin-bottom: 0;
    }

    d-title h1, d-title p, d-title figure,
    d-abstract p, d-abstract b {
      grid-column: page;
    }

    d-title .dt-tags {
      grid-column: page;
    }

    .dt-tags .dt-tag {
      text-transform: lowercase;
    }

    d-article h1 {
      line-height: 1.1em;
    }

    d-abstract p, d-article p {
      text-align: justify;
    }

    @media(min-width: 1000px) {
      .d-contents.d-contents-float {
        justify-self: end;
      }

      nav.toc {
        border-right: 1px solid rgba(0, 0, 0, 0.1);
        border-right-width: 1px;
        border-right-style: solid;
        border-right-color: rgba(0, 0, 0, 0.1);
      }
    }

    .posts-list .dt-tags .dt-tag {
      text-transform: lowercase;
    }

    @keyframes highlight-target {
      0% {
        background-color: #ffa;
      }
      66% {
        background-color: #ffa;
      }
      100% {
        background-color: none;
      }
    }

    d-article :target, d-appendix :target {
       animation: highlight-target 3s;
    }
  </style>


</head>

<body>

<!--radix_placeholder_front_matter-->

<script id="distill-front-matter" type="text/json">
{"title":"A Unifying Framework for Parallel and Distributed Processing in R using Futures","description":[],"doi":"10.32614/RJwrapper","authors":[]}
</script>

<!--/radix_placeholder_front_matter-->
<!--radix_placeholder_navigation_before_body-->
<!--/radix_placeholder_navigation_before_body-->
<!--radix_placeholder_site_before_body-->
<!--/radix_placeholder_site_before_body-->

<div class="d-title">
<h1>A Unifying Framework for Parallel and Distributed Processing in R using Futures</h1>
<!--radix_placeholder_categories-->
<!--/radix_placeholder_categories-->

</div>


<div class="d-article">
<p>by Henrik Bengtsson <em>by Henrik Bengtsson</em></p>
<p><strong>Abstract</strong> A <em>future</em> is a programming
construct designed for concurrent and asynchronous evaluation of code,
making it particularly useful for parallel processing. The future
package implements the <em>Future API</em> for programming with futures
in R. This minimal API provides sufficient constructs for implementing
parallel versions of well-established, high-level map-reduce APIs. The
future ecosystem supports exception handling, output and condition
relaying, parallel random number generation, and automatic
identification of globals lowering the threshold to parallelize code.
The <em>Future API</em> bridges parallel frontends with parallel
backends, following the philosophy that end-users are the ones who
choose the parallel backend while the developer focuses on what to
parallelize. A variety of backends exist, and third-party contributions
meeting the specifications, which ensure that the same code works on all
backends, are automatically supported. The future framework solves
several problems not addressed by other parallel frameworks in R.</p>
<h1 id="introduction">Introduction</h1>
<p>Parallel processing can be used to speed up computationally intensive
tasks. As the size of these tasks and access to more CPU cores tend to
grow over time, so does the demand for parallel-processing solutions. In
R, there exist several frameworks for running code in parallel, many
dating back more than a decade <span class="citation"
data-cites="Schmidberger2009">(<a href="#ref-Schmidberger2009"
role="doc-biblioref">Schmidberger et al. 2009</a>)</span>. R gained
built-in support via the parallel package in version 2.14.0 (2011),
which to date probably provides the most, either directly or indirectly,
commonly used solutions. For an overview of current parallel techniques
available to R developers, see <span class="citation"
data-cites="Eddelbuettel2020">Eddelbuettel (<a
href="#ref-Eddelbuettel2020" role="doc-biblioref">2021</a>)</span> and
the <a
href="https://CRAN.R-project.org/view=HighPerformanceComputing"><em>High-Performance
and Parallel Computing with R</em></a> CRAN Task View.</p>
<p>The options for parallelizing <em>computations</em> in R can be
grouped broadly into those that can be used to parallelize R code, such
as what the parallel package provides, and those that are used to
parallelize native code, such as C, C++, and Fortran, and are often not
specific to R itself. For example, multi-threaded processing is an
efficient parallelization technique which operates at the core of the
operating system and the CPU and allows for updating shared memory in
parallel and more, which is not available at the R level. In contrast,
parallelization at the R level takes place at a higher level with a
coarser type of parallelization, which we refer to as
<em>multi-process</em> parallelization. In addition to parallel
computations, there are also efforts in R for working with <em>parallel
data structures</em>, e.g., <a
href="https://CRAN.R-project.org/package=sparklyr">sparklyr</a> <span
class="citation" data-cites="CRAN:sparklyr">(<a
href="#ref-CRAN:sparklyr" role="doc-biblioref">Luraschi et al.
2021</a>)</span> and the <em>Programming with Big Data in R</em> (pbdR)
project <span class="citation" data-cites="Schmidt2017">(<a
href="#ref-Schmidt2017" role="doc-biblioref">Schmidt et al.
2017</a>)</span>. By pre-distributing data and storing them on, or near,
parallel workers, the overhead from passing data on-the-fly in parallel
processing can be decreased, resulting in an overall faster processing
time but also lower and more fine-tuned memory requirements. This
article proposes a solution for <em>parallelizing computations at the R
level</em>.</p>
<p>The <a href="https://CRAN.R-project.org/package=future">future</a>
package <span class="citation" data-cites="CRAN:future">(<a
href="#ref-CRAN:future" role="doc-biblioref">Bengtsson 2021b</a>)</span>
aims to provide a unifying, generic, minimal application protocol
interface (API) to facilitate the most common types of parallel
processing in R, especially the <em>manager-worker</em> strategy where
an R process delegates tasks to other R processes. It builds upon the
concepts of <em>futures</em> <span class="citation"
data-cites="HewittBaker_1977">(<a href="#ref-HewittBaker_1977"
role="doc-biblioref">Hewitt and Baker 1977</a>)</span> and
<em>promises</em> <span class="citation"
data-cites="FriedmanWise_1978 Hibbard_1976">(<a href="#ref-Hibbard_1976"
role="doc-biblioref">Hibbard 1976</a>; <a href="#ref-FriedmanWise_1978"
role="doc-biblioref">Friedman and Wise 1978</a>)</span> - concepts that
are well suited for a functional language such as R. To better
understand how it fits in among and relates to existing parallelization
solutions in R<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>, let us revisit the two most
well-known solutions - packages parallel and <a
href="https://CRAN.R-project.org/package=foreach">foreach</a>.</p>
<p>The parallel package has a set of functions for calling functions and
expressions in parallel across one or more concurrent R processes. The
most well-known functions for this are mclapply() and parLapply(), which
mimic the behavior of the map-reduce<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a> function lapply() in the
base package. Below is an example showing them calling a “slow” function
on each element in a vector using two parallel workers. First, to do
this through sequentially processing, we can use lapply():</p>
<div class="example">
<p>xs &lt;- 1:10 y &lt;- lapply(xs, function(x) slow_fcn(x) )</p>
</div>
<p>To do the same in parallel using two <em>forked</em> parallel
processes, we can use:</p>
<div class="example">
<p>library(parallel) xs &lt;- 1:10 y &lt;- mclapply(xs, function(x)
slow_fcn(x) , mc.cores = 2)</p>
</div>
<p>Alternatively, to run it in parallel using two R parallel processes
running in the <em>background</em>, we can do:</p>
<div class="example">
<p>library(parallel) workers &lt;- makeCluster(2) clusterExport(workers,
"slow_fcn") xs &lt;- 1:10 y &lt;- parLapply(workers, xs, function(x)
slow_fcn(x) )</p>
</div>
<p>These functions, which originate from legacy packages <a
href="https://CRAN.R-project.org/package=multicore">multicore</a> (2009-2014,
<span class="citation" data-cites="CRAN:multicore">Urbanek (<a
href="#ref-CRAN:multicore" role="doc-biblioref">2014</a>)</span>) and <a
href="https://CRAN.R-project.org/package=snow">snow</a> (since 2003,
<span class="citation" data-cites="CRAN:snow">Tierney et al. (<a
href="#ref-CRAN:snow" role="doc-biblioref">2021</a>)</span>), are
designed for specific parallelization frameworks. The mclapply() set of
functions relies on process <em>forking</em> by the operating system,
which makes them particularly easy to use. This is because each worker
automatically inherits the setup and all of the content of the main R
process’ workspace, making it straightforward to replace a sequential
lapply() call with a parallel mclapply() call. This has made it popular
among Linux and macOS developers. On MS Windows, where R does not
support forked processing, mclapply() falls back to using lapply()
internally.</p>
<p>The parLapply() set of functions, which all operating systems
support, rely on a cluster of R background workers for parallelization.
It works by the main R process and the workers exchanging tasks and
results over a communication channel. The default and most commonly used
type of cluster is SOCK, which MS Windows also supports, and it
communicates via <em>socket connections</em>. Like most other cluster
types, SOCK clusters require developers to manually identify and export
packages and global objects to the workers by calling clusterEvalQ() and
clusterExport(), before calling parLapply(), which increases the barrier
to use them.</p>
<h2 id="mixed-responsibilities">Mixed responsibilities of developers or
end-users</h2>
<p>Using either the mclapply() or the parLapply() approach works well
when developers and end-users can agree on which framework to use.
Unfortunately, this is not always possible, e.g., R package developers
rarely know who the end-users are and what compute resources they have.
Regardless, developers who wish to support parallel processing still
face the problem of deciding which parallel framework to target, a
decision that often has to be done early in the development cycle. This
means deciding on what <em>type of parallelism</em> to support, e.g.,
forked processing via mclapply() or SOCK clusters via parLapply(). This
decision is critical because it limits the end-user’s options, and any
change, later on, might be expensive because of, for instance, having to
rewrite and retest part of the codebase. A developer who wishes to
support multiple parallel backends has to implement support for each of
them individually and provide the end-user with a mechanism to choose
between them. This approach often results in unwieldy, hard-to-maintain
code of conditional statements with low test coverage, e.g.,</p>
<div class="example">
<p>if (parallel == "fork") ... else if (parallel == "SOCK") ... else if
(parallel == "MPI") ... else ...</p>
</div>
<p>There is no established standard for doing this, which results in
different packages providing different mechanisms for controlling the
parallelization method, if at all.</p>
<p>Functions like parLapply() partly address the problem of supporting
multiple parallelization frameworks because they support various types
of parallel cluster backends referred to as “snow” clusters (short for
<em>Simple Network of Workstations</em> and from their origin in the
snow package), e.g., workers &lt;- makeCluster(4, type = "FORK") sets up
a cluster that parallelizes using forked processing, and
workers &lt;- makeCluster(4, type = "MPI") sets up a cluster that
parallelizes via a Message Passing Interface (MPI) framework. If a
developer uses parLapply(), they could write their code such that the
end-user can specify what type of snow cluster to use, e.g., by
respecting what the end-user set via setDefaultCluster(workers). This
provides the end-user with more, although in practice limited, options
on how and where to execute code in parallel. Unfortunately, it is
rather common that the cluster type is hard-coded inside packages giving
end-users little to no control over the parallelization mechanism, other
than possibly the number of cores to use.</p>
<h2
id="map-reduce-parallelization-with-more-control-for-the-end-user">Map-reduce
parallelization with more control for the end-user</h2>
<p>Possibly inspired by the snow-style clusters, the foreach
package <span class="citation"
data-cites="CRAN:foreach Kane_etal_2013">(<a href="#ref-Kane_etal_2013"
role="doc-biblioref">Kane et al. 2013</a>; <a href="#ref-CRAN:foreach"
role="doc-biblioref">Microsoft and Weston 2020</a>)</span>, first
released in 2009, addresses the above problem of having to decide on the
parallel design early on by letting the end-user - not the developer -
“register” what type of parallel backend (“foreach adaptor”) to use when
calling foreach(). For example, with <a
href="https://CRAN.R-project.org/package=doMC">doMC</a> <span
class="citation" data-cites="CRAN:doMC">(<a href="#ref-CRAN:doMC"
role="doc-biblioref">Revolution Analytics and Weston 2020</a>)</span>,
one can register a multicore cluster, and with <a
href="https://CRAN.R-project.org/package=doParallel">doParallel</a> <span
class="citation" data-cites="CRAN:doParallel">(<a
href="#ref-CRAN:doParallel" role="doc-biblioref">Microsoft Corporation
and Weston 2020</a>)</span>, one can register any type of “snow” cluster
as in:</p>
<p>We note that the specification of what type of parallel framework and
number of cores to use is separated from the foreach() map-reduce
construct itself. This gives more control to the end-user on
<em>how</em> and <em>where</em> to parallelize, leaving the developer to
focus on <em>what</em> to parallelize, which is a design pattern of
great value with important implications on how to design, write, and
maintain parallel code. The large uptake of foreach since it was first
released supports this. As of November 2021, foreach is among the
top-1.0% most downloaded packages on CRAN, and there are 867 packages on
CRAN and Bioconductor that directly depend on it. Another advantage of
the separation between the map-reduce frontend API and parallel backend
(foreach adaptors) is that new types of parallel backends can be
introduced without the need to make updates to the foreach package. This
has led to third-party developers have contributed additional foreach
adaptors, e.g., <a
href="https://CRAN.R-project.org/package=doMPI">doMPI</a> <span
class="citation" data-cites="CRAN:doMPI">(<a href="#ref-CRAN:doMPI"
role="doc-biblioref">Weston 2017</a>)</span> and <a
href="https://CRAN.R-project.org/package=doRedis">doRedis</a> <span
class="citation" data-cites="CRAN:doRedis">(<a href="#ref-CRAN:doRedis"
role="doc-biblioref">Lewis 2020</a>)</span>.</p>
<p>Unfortunately, there is no <em>exact</em> specification on what a
foreach adaptor should support and how it should act in certain
situations, which has resulted in adaptors behaving slightly
differently. At their face value, these differences appear innocent but
may cause different outcomes of the same code. In the best case, these
differences result in run-time errors, and in the worst case, different
results. An example of the former is the difference between doMC on
Unix-like systems and doParallel on Windows. Analogously to mclapply(),
when using doMC, globals and packages are automatically taken care of by
the process forking. In contrast, when using doParallel with “snow”
clusters, globals and packages need to be identified and explicitly
exported, via additional arguments .export and .packages to foreach(),
to the parallel workers running in the background. Thus, a developer
that only uses doMC might forget to test their code with doParallel,
where it may fail. Having said this, the foreach package does provide a
rudimentary mechanism for automatically identifying and exporting global
variables. However, it has some limitations, that, in practice, require
the developer to explicitly specify globals to make sure their code
works with more backends. Some adaptors provide additional options of
their own that are specified as arguments to foreach(). If the developer
specifies such options, the foreach() call might not work with other
adaptors.</p>
<p>To develop foreach() code invariant to the parallel backend chosen
requires a good understanding of how the foreach framework works and
plenty of testing. This lack of strict behavior is unfortunate and might
have grown out of a strategy of wanting to keep things flexible. On the
upside, steps have recently<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a> been taken toward making
the behavior more consistent across foreach backends, suggesting that it
is possible to remove several of these weaknesses through a process of
deprecating and removing unwanted side effects over several release
cycles in close collaboration with package developers currently relying
on such backend-specific properties.</p>
<h1 id="the-future-framework">The future framework</h1>
<p>The future package defines and implements the <em>Future API</em> - a
minimal, unifying, low-level API for parallel processing, and more.
Contrary to the aforementioned solutions, this package does <em>not</em>
offer a parallel map-reduce API per se. Instead, it focuses on providing
efficient and simple-to-use atomic building blocks that allow us to
implement such higher-level functions elsewhere.</p>
<h2 id="low-level-generalized-parallelization-model">Three atomic
constructs that unify common parallel design patterns</h2>
<div class="samepage">
<p>The <em>Future API</em> comprises three fundamental constructs:</p>
<ul>
<li><p>f &lt;- future(expr) : evaluates an expression via a future
(non-blocking, if possible)</p></li>
<li><p>v &lt;- value(f) : the value of the future expression expr
(blocking until resolved)</p></li>
<li><p>r &lt;- resolved(f) : TRUE if future is resolved, otherwise FALSE
(non-blocking)</p></li>
</ul>
</div>
<p>To help understand what a future is, let us start with R’s assignment
construct:</p>
<div class="example">
<p>v &lt;- expr</p>
</div>
<p>Although it is effectively a single operator, there are two steps in
an assignment: first (i) R evaluates the <em>expression</em> on the
right-hand side (RHS), and then (ii) it assigns the resulting value to
the <em>variable</em> on the left-hand side (LHS). We can think of the
<em>Future API</em> as giving us full access to these two steps by
rewriting the assignment construct as:</p>
<div class="example">
<p>f &lt;- future(expr) v &lt;- value(f)</p>
</div>
<p>Contrary to the regular assignment construct where the evaluation of
the expression and the assignment of its value are tightly coupled, the
future construct allows us to decouple these steps, which is an
essential property of futures and necessary when doing parallel
processing<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>. Especially, the decoupling allows
us to perform other tasks in-between the step that evaluates the
expression and the step that assigns its value to the target variable.
Here is an example that creates a future that calculates slow_fcn(x)
with x being 1, then reassigns a different value to x, and finally gets
the value of the future expression:</p>
<div class="example">
<p>x &lt;- 1 f &lt;- future( slow_fcn(x) ) x &lt;- 2 v &lt;-
value(f)</p>
</div>
<p>By definition, a future consists of an R expression and any required
objects as they were when the future was created. Above, the recorded
objects are the function slow_fcn() and the variable x with value 1.
This is why the value of the future is unaffected by x getting
reassigned a new value after the future is created but before the value
is collected.</p>
<p>We have yet to explain how futures are resolved, that is, how the
future expression is evaluated. This is the part where futures naturally
extend themselves to asynchronous and parallel processing. How a future
is resolved depends on what <em>future backend</em> is set. If not
specified, the default is to resolve futures sequentially, which
corresponds to setting:</p>
<div class="example">
<p>plan(sequential)</p>
</div>
<p>Before we continue, it should be emphasized that the <em>Future
API</em> is designed so that a program using it gives the same results
no matter how and where the futures are resolved, may it be sequentially
on the local machine or in parallel on a remote cluster. As a
consequence, <em>the future ecosystem is designed to separate the
responsibilities of the developer from those of the end-user</em>. This
allows the developer to focus on the code to be parallelized while the
end-user focuses on how to parallelize. It is the end-user who decides
on the plan(). For example, if they specify:</p>
<div class="example">
<p>plan(multisession)</p>
</div>
<p>before calling the above future code, futures will be resolved in
parallel via a SOCK cluster on the local machine similar to what we used
above in the parLapply() example. If the end-user instead specifies
plan(multicore), futures will be resolved in parallel in the background
via <em>forked</em> R processes using the same framework as mclapply().
Importantly, regardless of what future plan is used, and regardless of
whether or not we assigned a new value to x after creating the future,
the result is always the same. Since we, as developers, do not know what
backend end-users will use, we also cannot know <em>when</em> a future
is resolved. This is why we say that “a future evaluates its expression
<em>at some point in the future</em>”. What we do know is that value()
returns the value of the future only when it is resolved, and if it is
not resolved, then value() waits until it is.</p>
<p>Next, let us look at how blocking works by using an example where we
create three futures to be resolved by two parallel workers:</p>
<div class="example">
<p>library(future) plan(multisession, workers = 2)</p>
<p>xs &lt;- 1:10</p>
<p>f1 &lt;- future( slow_fcn(xs<span class="math display">\[1\]</span>)
)</p>
<p>f2 &lt;- future( slow_fcn(xs<span class="math display">\[2\]</span>)
)</p>
<p>f3 &lt;- future( slow_fcn(xs<span class="math display">\[3\]</span>)
)</p>
</div>
<p>Here, the first two futures are created in a non-blocking way because
there are two workers available to resolve them. However, when we
attempt to create a third future, there are no more workers available.
This causes future() to block until one of the workers is available,
that is, until either one or both of the two futures have been resolved.
If three or more workers are set up, then the third future() call would
not block. On the other hand, if plan(sequential) is set, then each
future() blocks until the previously created future has been resolved.
Finally, to retrieve the values of the three futures, we do:</p>
<div class="example">
<p>v1 &lt;- value(f1) v2 &lt;- value(f2) v3 &lt;- value(f3)</p>
</div>
<p>Although it is common to call value() on the futures in the order we
created them, we can collect the values in any order, which is something
we will return to later.</p>
<div class="center">
<figure>
<embed src="figures/future-lapply-4workers.pdf"
id="figure:future-4workers" />
<figcaption aria-hidden="true">An illustration of parallel processing
using futures via four R processes running in the background. Base R
lapply()</figcaption>
</figure>
<p>is used to call slow_fcn() ten times - once per element in xs. By
calling it via future(), each call is distributed out to one of four
workers. If all workers are busy, the next future, in turn, will wait
for a worker to become available. The results of all futures are
collected at the end. Any output, warnings, and errors produced on the
workers are relayed as-is back on the main R session. The four workers
were created using plan(multisession, workers = 4). If switching to
plan(sequential), then all futures are resolved sequentially in the main
R process. Only core Future API functions from the future package were
used. Less verbose, map-reduce alternatives are available in the
high-level future packages such as future.apply, furrr, and doFuture.
<span id="figure:future-4workers"
label="figure:future-4workers"></span></p>
</div>
<p>Continuing, we can generalize the above to calculate slow_fcn() on
each of the elements in xs via futures. For this, we can use a regular
for-loop to create each of the length(xs) futures:</p>
<div class="example">
<p>xs &lt;- 1:10 fs &lt;- list() for (i in seq_along(xs)) fs<span
class="math display">\[\[i\]</span>] &lt;- future(slow_fcn(xs<span
class="math display">\[i\]</span>))</p>
</div>
<p>Note how we here have effectively created a <em>parallel
for-loop</em>, where plan() controls the amount of parallelization. To
collect the values of these futures, we can use<a href="#fn5"
class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>:</p>
<div class="example">
<p>vs &lt;- lapply(fs, value)</p>
</div>
<p>Alternatively, to using a for-loop, we can parallelize using
lapply():</p>
<div class="example">
<p>xs &lt;- 1:10 fs &lt;- lapply(xs, function(x) future(slow_fcn(x))
)</p>
</div>
<p>This is illustrated in Figure <a href="#figure:future-4workers"
data-reference-type="ref" data-reference="figure:future-4workers">1</a>,
where four background workers created by plan(multisession, workers = 4)
is used to resolve the futures. The same idea also applies to other
types of map-reduce functions. This shows how powerful the <em>Future
API</em> is; by combining base R with the two constructs future() and
value(), we have created rudimentary<a href="#fn6" class="footnote-ref"
id="fnref6" role="doc-noteref"><sup>6</sup></a> alternatives to
mclapply(), parLapply(), and foreach(). Indeed, we could reimplemented
these parallel and foreach functions using the <em>Future API</em>.</p>
<p>The resolved() function queries, in a non-blocking way, whether or
not a future is resolved. Among other things, this can be used to
collect the value of a subset of resolved futures as soon as possible
without risking to block from collecting the value of a non-resolved
future, which allows additional futures to launch sooner, if they exist.
This strategy also helps lower the overall latency that comes from the
overhead of collecting values from futures - values that may contain
large objects and are collected from remote machines over a network with
limited bandwidth. As explained further below, collecting the value of
futures as soon as possible will also lower the latency of the relay of
output and conditions (e.g., warnings and errors) captured by each
future while they evaluate the future expressions.</p>
<p>In summary, the three constructs of the <em>Future API</em> provide
<em>the necessary and sufficient</em> functionality for evaluating R
expressions in parallel, which in turn may be used to construct
higher-level map-reduce functions for parallel processing. Additional
core features of futures that are useful, or even essential, for
parallel processing are presented next.</p>
<h2 id="error-handling">Exception handling</h2>
<p>To make it as simple as possible to use futures, they are designed to
mimic the behavior of the corresponding code that does not use futures.
An important part of this design aim is how exception handling is done.
Any <em>error</em> produced while resolving a future, that is,
evaluating its expression, is captured and relayed as-is in the main R
process each time value() is called. This mimics the behavior of how
errors are produced when not using futures. This is illustrated by the
following two code examples – with futures:</p>
<div class="example">
<p>x &lt;- "24" f &lt;- future(log(x)) v &lt;- value(f) # Error in
log(x) : non-numeric argument to mathematical function</p>
</div>
<p>and without futures:</p>
<div class="example">
<p>x &lt;- "24" v &lt;- log(x) # Error in log(x) : non-numeric argument
to mathematical function</p>
</div>
<p>As a result, standard mechanisms for condition handling also apply to
errors relayed by futures. For example, to assign a missing value to v
whenever there is an error, we can use:</p>
<div class="example">
<p>v &lt;- tryCatch( value(f) , error = function(e) NA_real_ )</p>
</div>
<p>Errors due to extraordinary circumstances, such as terminated R
workers and failed communication, are of a different kind than the above
evaluation errors. Because of this, they are signaled as errors of class
<em>FutureError</em> so they can be handled specifically, e.g., by
restarting R workers or relaunching the failed future elsewhere (Section
‘Future work’).</p>
<h2
id="relaying-of-standard-output-and-conditions-e.g.messages-and-warnings">Relaying
of standard output and conditions (e.g., messages and warnings)</h2>
<p>Futures capture the standard output (<em>stdout</em>) and then relay
it in the main R process each time value() is called. Analogously, all
conditions are captured and relayed as-is in the main R process each
time value() is called. Common conditions relayed this way are
<em>message</em>s and <em>warning</em>s as generated by message() and
warning(). The relaying of errors was discussed in the previous section.
Relaying of standard output and conditions respects the order they were
captured, except that all of the standard output is relayed before
conditions are relayed in the order they were signaled. For example,</p>
<div class="example">
<p>x &lt;- c(1:10, NA) f &lt;- future( cat("Hello world") y &lt;- sum(x,
na.rm = TRUE) message("The sum of ‘x’ is ", y) if (anyNA(x))
warning("Missing values were omitted", call. = FALSE) cat("Bye bye") y )
v &lt;- value(f) # Hello world # Bye bye # The sum of ‘x’ is 55 #
Warning message: # Missing values were omitted</p>
</div>
<p>Standard techniques can be used to capture the relayed standard
output, e.g.,</p>
<div class="example">
<p>stdout &lt;- capture.output( v &lt;- value(f) ) # The sum of ‘x’ is
55 # Warning message: # Missing values were omitted</p>
<p>stdout # <span class="math display">\[1\]</span> "Hello world" "Bye
bye"</p>
</div>
<p>Similarly, withCallingHandlers() and globalCallingHandlers() can be
used to capture and handle the different classes of conditions being
relayed. Note that all of the above works the same way regardless of
what future backend is used, including when futures are resolved on a
remote machine.</p>
<p>Relaying of standard output, messages, warnings, and errors
simplifies any troubleshooting. For example, existing verbose output
helps narrow down the location of errors and warnings, which may reveal
unexpected missing values or vector recycling. Commonly used poor-man
debugging, where temporary debug messages are injected into the code, is
also possible because of this built-in relay mechanism. Imagine a
logging framework that leverages R’s condition framework to signal
different levels of log events and then captures and reports, e.g., to
the terminal or to file. It will work out of the box when parallelizing
with futures.</p>
<p>Conditions of class <em>immediateCondition</em> are treated specially
by the future framework. They are by design allowed to be relayed as
soon as possible, and not only when value() is called. For instance,
they may be relayed when calling resolved(), or even sooner, depending
on the future backend used. Because of this, <em>immediateCondition</em>
conditions are relayed without respecting the order of other types of
conditions captured. This makes them suitable for signaling, for
instance, <em>progress updates</em>. Thus, such progress conditions can
be used to update a progress bar in the terminal or in a Shiny
application while originating from futures being resolve on remote
machines. See the <a
href="https://CRAN.R-project.org/package=progressr">progressr</a>
package <span class="citation" data-cites="CRAN:progressr">(<a
href="#ref-CRAN:progressr" role="doc-biblioref">Bengtsson
2021h</a>)</span> for an implementation of this. Note, however, that
this type of near-live relaying of <em>immediateCondition</em>s only
works for backends that have the means to communicate these conditions
from the worker back to the main R session, while the worker still
processes the future. When non-supporting backends are used, these
conditions are relayed together with other captured conditions at the
very end when the future has been resolved.</p>
<p><em>Comment:</em> Contrary to the standard output, due to limitations
in R<a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>, it is not possible to capture the
standard error reliably. Because of this, any output to the standard
error is silently ignored, e.g., cat("some output", file = stderr()).
However, although output from message() is sent to the standard error,
it is indeed outputted in the main R processes because it is the message
conditions that are captured and relayed, not the standard error.</p>
<h2 id="global-variables">Globals and packages</h2>
<p>The future framework is designed to make it as simple as possible to
implement parallel code. Another example of this is the automatic
identification of <em>globals</em> - short for global variables and
functions - that are required for a future expression to be resolved
successfully. For example, in:</p>
<div class="example">
<p>f &lt;- future( slow_fcn(x) )</p>
</div>
<p>the globals of the future expression are slow_fcn() and x. By
default, future() will attempt to identify, locate, and record these
globals internally via static code inspection, such that they are
available when the future is resolved. If one of these globals is part
of a package namespace, that is also recorded. Because of this,
developers rarely need to worry about globals when programming with
futures. However, occasionally, the future expression is such that it is
not possible to infer all the globals. For example, the following
produces an error:</p>
<div class="example">
<p>plan(multisession) k &lt;- 42 f &lt;- future( get("k") ) v &lt;-
value(f) # Error in get("k") : object ‘k’ not found</p>
</div>
<p>This is because code inspection cannot infer that k is a needed
variable. In such cases, one can guide the future framework to identify
this missing global by explicitly mentioning it at the top of the future
expression, e.g.,</p>
<div class="example">
<p>f &lt;- future( k get("k") )</p>
</div>
<p>Alternatively, one can specify it via argument globals when creating
the future, e.g.,</p>
<div class="example">
<p>f &lt;- future( get("k") , globals = "k")</p>
</div>
<p>See help("future", package = "future") for all options available to
control which globals to use and how to ignore false positives.</p>
<p>Internally, the future framework uses <a
href="https://CRAN.R-project.org/package=globals">globals</a> <span
class="citation" data-cites="CRAN:globals">(<a href="#ref-CRAN:globals"
role="doc-biblioref">Bengtsson 2020</a>)</span>, and indirectly <a
href="https://CRAN.R-project.org/package=codetools">codetools</a> <span
class="citation" data-cites="CRAN:codetools">(<a
href="#ref-CRAN:codetools" role="doc-biblioref">Tierney
2020</a>)</span>, to identify globals by walking the abstract syntax
tree (AST) of the future expression in order. It uses an
<em>optimistic</em> search strategy to allow for some false-positive
globals to minimize the number of false-negative globals. Contrary to
false positives, false negatives cause futures to produce errors similar
to the one above.</p>
<h2 id="proper-parallel-random-number-generation-rng">Proper parallel
random number generation</h2>
<p>The ability to produce high-quality random numbers is essential for
the validity of many statistical analyses, e.g., bootstrap, permutation
tests, and simulation studies. R has functions at its core for drawing
random numbers from common distributions. This R functionality is also
available to C and Fortran native code. All draw from the same internal
pseudo-random number generator (RNG). Different kinds of RNGs are
available, with Mersenne-Twister <span class="citation"
data-cites="Matsumoto_Nishimura:1998">(<a
href="#ref-Matsumoto_Nishimura:1998" role="doc-biblioref">Matsumoto and
Nishimura 1998</a>)</span> being the default. Like most other RNGs, the
Mersenne-Twister RNG is not designed for concurrent processing - if used
in parallel, one risks producing random numbers that are correlated.
Instead, for parallel processing, the multiple-recursive generator
L’Ecuyer-CMRG by <span class="citation"
data-cites="LEcuyer:1999">L’Ecuyer (<a href="#ref-LEcuyer:1999"
role="doc-biblioref">1999</a>)</span>, implemented in the parallel
package, can be used to set up multiple RNG streams. The future
ecosystem has built-in support for L’Ecuyer-CMRG at its core to make it
as easy as possible to produce statistically sound and reproducible
random numbers regardless of how and where futures are resolved,
e.g.,</p>
<div class="example">
<p>f &lt;- future(rnorm(3), seed = TRUE) value(f) # <span
class="math display">\[1\]</span> -0.02648871 -1.73240257 0.78139056</p>
</div>
<p>Above, seed = TRUE is used to specify that parallel RNG streams
should be used. When used, the result will be fully reproducible
regardless of future backend specified and the number of workers
available. Because seed = TRUE can introduce significant overhead, the
default is seed = FALSE. However, since it is computationally cheap to
detect when a future expression produced random numbers, the future
framework will generate an informative warning when this is used by
mistake to help lower the risk of producing statistically questionable
results. It is possible to disable this check or to escalate the warning
to an error via an R option. All higher-level parallelization APIs that
build upon futures must adhere to this parallel-RNG design, e.g., <a
href="https://CRAN.R-project.org/package=future.apply">future.apply</a>
and <a href="https://CRAN.R-project.org/package=furrr">furrr</a>.</p>
<h2 id="secFutureAssignmentConstruct">Future assignment construct</h2>
<p>As an alternative for using future() and value(), the future package
provides a <em>future-assignment operator</em>, %&lt;-%, for
convenience. It is designed to mimic the regular assignment operator,
&lt;-, in R:</p>
<div class="example">
<p>v &lt;- expr</p>
</div>
<p>By replacing the above with:</p>
<div class="example">
<p>v</p>
</div>
<p>the RHS expression expr will be evaluated using a future whose value
is assigned to the LHS variable v as a <em>promise</em><a href="#fn8"
class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.
Because the LHS is a promise, the value of the future will not be
assigned to it until we attempt to access the promise. As soon as we try
to use v, say,</p>
<div class="example">
<p>y &lt;- sqrt(v)</p>
</div>
<p>the associated promise will call value() on the underlying future,
while possibly blocking, and at the end assign the collected result to
v<a href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>. From there on, v is a regular
value. As an illustration, our introductory example with three futures
can be written as<a href="#fn10" class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a>:</p>
<div class="example">
<p>xs &lt;- 1:10 v1 v2 v3</p>
</div>
<p>and with, say, plan(multisession), these statements will be processed
in parallel.</p>
<p>Special <em>infix operators</em> are available to specify arguments
that otherwise would be passed to the future() function. For example, to
set seed = TRUE, we can use:</p>
<div class="example">
<p>v</p>
</div>
<p>See help("%&lt;-%", package = "future") for other infix
operators.</p>
<p>Regular R assignments can often be replaced by future assignments
as-is. However, because future assignments rely on promises, and
promises can only be assigned to <em>environment</em>s, including the
working environment, they cannot be used to assign to, for instance,
<em>list</em>s. As a workaround, one can use a <em>list environment</em>
instead of a <em>list</em>. They are implemented in the <a
href="https://CRAN.R-project.org/package=listenv">listenv</a>
package <span class="citation" data-cites="CRAN:listenv">(<a
href="#ref-CRAN:listenv" role="doc-biblioref">Bengtsson
2019</a>)</span>. A list environment is technically an
<em>environment</em> that emulates most properties of a <em>list</em>,
including indexing as in:</p>
<div class="example">
<p>xs &lt;- 1:10 vs &lt;- listenv::listenv() for (i in seq_along(xs))
vs<span class="math display">\[\[i\]</span>] vs &lt;- as.list(vs)</p>
</div>
<h2 id="protection-against-nested-parallelism">Nested parallelism and
protection against it</h2>
<p>A problem with parallel processing in software stacks like the R
package hierarchy is the risk of overloading the CPU cores due to nested
parallelism. For instance, assume that package PkgA calls
PkgB::estimate() in parallel using all <span
class="math inline">\(N\)</span> cores on the current machine.
Initially, the estimate() function was implemented to run sequentially,
but, in a recent PkgB release, it was updated to parallelize internally
using all <span class="math inline">\(N\)</span> cores. Without built-in
protection, this update now risks running <span
class="math inline">\(N^2\)</span> parallel workers when PkgA is used,
possibly without the awareness of either maintainer.</p>
<p>The future package has built-in protection against nested
parallelism. This works by configuring each worker to run in sequential
mode unless nested parallelism is explicitly configured. This is
achieved by setting options and environment variables that are known to
control parallelism in R, e.g., options(mc.cores = 1). Because of this,
if PkgA and PkgB parallelize using the future framework, the nested
parallelism above will run with a total of <span
class="math inline">\(N\)</span> cores, not <span
class="math inline">\(N^2\)</span> cores. This will also be true for
non-future code that respects such settings, e.g., when PkgB uses
parallel::mclapply() with the default mc.cores argument.</p>
<p>Nested parallelism can be configured by the end-user via plan(). For
example, to use two workers for the first layer of parallelization and
three for the second, use:</p>
<div class="example">
<p>plan(list( tweak(multisession, workers = 2), tweak(multisession,
workers = 3) ))</p>
</div>
<p>This will run at most <span class="math inline">\(2 \times 3 =
6\)</span> tasks in parallel on the local machine. Any nested
parallelism beyond these two layers will be processed in sequential
mode. That is, plan(sequential) is implicit if not specified. When
argument workers is not specified, it defaults to
parallelly::availableCores(), which respect a large number of
environment variables and R options specifying the number of cores.
Because of this, and due to the built-in protection against nested
parallelism, using plan(list(multisession, multisession)) effectively
equals using plan(list(multisession, sequential)).</p>
<p>A more common scenario of nested parallelism is when we submit tasks
to a job scheduler on a compute cluster where each job is allowed to run
on multiple cores allotted by the scheduler. As clarified later, this
may be configured as:</p>
<div class="example">
<p>plan(list( future.batchtools::batchtools_sge, multisession ))</p>
</div>
<p>where the default workers = availableCores() assures that the number
of multisession workers used respects what the scheduler assigns to each
job.</p>
<h2 id="future-backends">Future backends</h2>
<p>In addition to implementing the <em>Future API</em>, the future
package also implements a set of future backends that are based on the
parallel package. If no backend is specified, the default is:</p>
<div class="example">
<p>plan(sequential)</p>
</div>
<p>which makes all futures to be resolved sequentially in the current R
session. To resolve futures in parallel on a SOCK cluster on the local
machine, use one of:</p>
<div class="example">
<p>plan(multisession) ## defaults to workers = availableCores()
plan(multisession, workers = 4)</p>
</div>
<p>Similarly, to resolving futures in parallel on the local machine via
<em>forked</em> processing, use one of:</p>
<div class="example">
<p>plan(multicore) ## defaults to workers = availableCores()
plan(multicore, workers = 4)</p>
</div>
<p>To resolve futures via <em>any</em> type of “snow” cluster, use the
cluster backend. For example, to use a traditional SOCK cluster or an
MPI cluster, use either of:</p>
<div class="example">
<p>workers &lt;- parallel::makeCluster(4) plan(cluster, workers =
workers)</p>
<p>workers &lt;- parallel::makeCluster(4, type = "MPI") plan(cluster,
workers = workers)</p>
</div>
<p>To use a SOCK cluster with two remote workers, use:</p>
<div class="example">
<p>plan(cluster, workers = c("n1.remote.org", "n2.remote.org"))</p>
</div>
<p>which is short for:</p>
<div class="example">
<p>workers &lt;- parallelly::makeClusterPSOCK(c("n1.remote.org",
"n2.remote.org")) plan(cluster, workers = workers)</p>
</div>
<p>This works as long as there is password-less SSH access to these
remote machines and they have R installed. Contrary to
parallel::makePSOCKcluster(), parallelly::makeClusterPSOCK() uses
reverse-tunneling techniques, which avoids having to configure
inward-facing port-forwarding in firewalls, something that requires
administrative rights.</p>
<h3 id="third-party-future-backends">Third-party future backends</h3>
<p>Besides these built-in future backends, other R packages available on
CRAN implement additional backends. As long as these backends conform to
the <em>Future API</em> specifications, as discussed in
Section ‘Validation’, they can be used as alternatives to the built-in
backends. For example, the <a
href="https://CRAN.R-project.org/package=future.callr">future.callr</a>
package <span class="citation" data-cites="CRAN:future.callr">(<a
href="#ref-CRAN:future.callr" role="doc-biblioref">Bengtsson
2021e</a>)</span> implements a future backend that resolves futures in
parallel on the local machine via R processes<a href="#fn11"
class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>,
orchestrated by the <a
href="https://CRAN.R-project.org/package=callr">callr</a> <span
class="citation" data-cites="CRAN:callr">(<a href="#ref-CRAN:callr"
role="doc-biblioref">Csárdi and Chang 2021</a>)</span> package,
e.g.,</p>
<div class="example">
<p>plan(future.callr::callr) ## defaults to workers = availableCores()
plan(future.callr::callr, workers = 4)</p>
</div>
<p>Another example is <a
href="https://CRAN.R-project.org/package=future.batchtools">future.batchtools</a> <span
class="citation" data-cites="CRAN:future.batchtools">(<a
href="#ref-CRAN:future.batchtools" role="doc-biblioref">Bengtsson
2021d</a>)</span>, which implements several types of backends on top of
the <a
href="https://CRAN.R-project.org/package=batchtools">batchtools</a> <span
class="citation" data-cites="Lang_etal_2017">(<a
href="#ref-Lang_etal_2017" role="doc-biblioref">Lang et al.
2017</a>)</span> package. Most notably, it provides backends that
resolve futures distributed on high-performance compute (HPC)
environments by submitting the futures as jobs to a job scheduler, e.g.,
Slurm, SGE, and Torque/PBS:</p>
<div class="example">
<p>plan(future.batchtools::batchtools_slurm)
plan(future.batchtools::batchtools_sge)
plan(future.batchtools::batchtools_torque)</p>
</div>
<p>Yet another example is the <a
href="https://CRAN.R-project.org/package=googleComputeEngineR">googleComputeEngineR</a>
package <span class="citation"
data-cites="CRAN:googleComputeEngineR">(<a
href="#ref-CRAN:googleComputeEngineR" role="doc-biblioref">Edmondson
2019</a>)</span>, which provides a “snow” cluster type that supports<a
href="#fn12" class="footnote-ref" id="fnref12"
role="doc-noteref"><sup>12</sup></a> resolving futures in the cloud on
the Google Compute Engine platform.</p>
<h1 id="implementation">Implementation</h1>
<p>The future framework is platform-independent and works on all
platforms, including Linux, Solaris, macOS, and MS Windows. It is
backward compatible with older versions of R back to R 3.1.2 (October
2014). The core packages future, <a
href="https://CRAN.R-project.org/package=parallelly">parallelly</a> <span
class="citation" data-cites="CRAN:parallelly">(<a
href="#ref-CRAN:parallelly" role="doc-biblioref">Bengtsson
2021g</a>)</span>, globals, and listenv are implemented in plain R
(without native code) to maximize cross-platform operability and to keep
installation simple. They are available on CRAN (since 2015). The
parallelly package implements enhancements to the parallel package
originally part of the future package. The <a
href="https://CRAN.R-project.org/package=digest">digest</a>
package <span class="citation" data-cites="CRAN:digest">(<a
href="#ref-CRAN:digest" role="doc-biblioref">Eddelbuettel et al.
2021</a>)</span> is used to produce universally unique identifiers
(UUIDs). Development is done toward a public Git repository hosted at <a
href="https://github.com/HenrikBengtsson/future"
class="uri">https://github.com/HenrikBengtsson/future</a>.</p>
<h2 id="validation">Validation</h2>
<p>Since correctness and reproducibility is essential to all data
processing, validation is a top priority and part of the design and
implementation throughout the future ecosystem. Several types of testing
are performed.</p>
<p>First, all the essential core packages part of the future framework,
future, parallelly, globals, and listenv, implement a rich set of
package tests. These are validated regularly across the wide range of
operating systems (Linux, Solaris, macOS, and MS Windows) and R versions
available on CRAN, on continuous integration (CI) services (GitHub
Actions, Travis CI, and AppVeyor CI), and on R-hub.</p>
<p>Second, for each new release, these packages undergo full
reverse-package dependency checks using revdepcheck <span
class="citation" data-cites="GitHub:revdepcheck">(<a
href="#ref-GitHub:revdepcheck" role="doc-biblioref">Csárdi and Wickham
2021</a>)</span>. As of November 2021, the future package is tested
against 210 direct reverse-package dependencies available on CRAN and
Bioconductor. These checks are performed on Linux with both the default
settings and when forcing tests to use multisession workers (SOCK
clusters), which further validates that globals and packages are
identified correctly.</p>
<p>Third, a suite of <em>Future API conformance tests</em> available in
the <a
href="https://CRAN.R-project.org/package=future.tests">future.tests</a>
package <span class="citation" data-cites="CRAN:future.tests">(<a
href="#ref-CRAN:future.tests" role="doc-biblioref">Bengtsson
2021f</a>)</span> validates the correctness of all future backends. Any
new future backend developed must pass these tests on complying with the
<em>Future API</em>. By conforming to this API, the end-user can trust
that the backend will produce the same correct and reproducible results
as any other backend, including the ones that the developer has tested
on. Also, by making it the responsibility of the backend developer to
assert that their new future backend conforms to the <em>Future
API</em>, we relieve other developers from having to test that their
future-based software works on all backends. It would be a daunting task
for a developer to validate the correctness of their software with all
existing backends. Even if they would achieve that, there may be
additional third-party future backends that they are not aware of, that
they do not have the possibility to test with, or that yet have not been
developed.</p>
<p>Fourth, since foreach is used by a large number of essential CRAN
packages, it provides an excellent opportunity for supplementary
validation. Specifically, we dynamically tweak the examples of foreach
and popular CRAN packages <a
href="https://CRAN.R-project.org/package=caret">caret</a>, <a
href="https://CRAN.R-project.org/package=glmnet">glmnet</a>, <a
href="https://CRAN.R-project.org/package=NMF">NMF</a>, <a
href="https://CRAN.R-project.org/package=plyr">plyr</a>, and <a
href="https://CRAN.R-project.org/package=TSP">TSP</a> to use the <a
href="https://CRAN.R-project.org/package=doFuture">doFuture</a>
adaptor <span class="citation" data-cites="CRAN:doFuture">(<a
href="#ref-CRAN:doFuture" role="doc-biblioref">Bengtsson
2021a</a>)</span>. This allows us to run these examples with a variety
of future backends to validate that the examples produce no run-time
errors, which indirectly validates the backends as well as the
<em>Future API</em>. In the past, these types of tests helped to
identify and resolve corner cases where automatic identification of
global variables would fail. As a side note, several of these
foreach-based examples fail when using a parallel foreach adaptor
because they do not properly export globals or declare package
dependencies. The exception is when using the sequential <em>doSEQ</em>
adaptor (default), fork-based ones such as doMC, or the generic
doFuture, which supports any future backend and relies on the future
framework for handling globals and packages<a href="#fn13"
class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a>.</p>
<p>Lastly, analogously to the above reverse-dependency checks of each
new release, CRAN and Bioconductor continuously run checks on all these
direct, but also indirect, reverse dependencies, which further increases
the validation of the <em>Future API</em> and the future ecosystem at
large.</p>
<h2 id="known-limitations">Known limitations</h2>
<p>When saving an R object to file or sending it to a parallel worker, R
uses a built-in technique called <em>serialization</em>, which allows a
complex object structure to be sent as a stream of bytes to its
destination, so it later can be reconstructed via
<em>unserialization</em>. The ability to serialize objects is
fundamental to all parallel processing, the exception being
shared-memory strategies such as forked parallel processing. For
example, this is how future expressions and variables are sent to
parallel workers and how results are returned.</p>
<p>However, some types of objects are by design bound to the R session
where they are created and cannot be used as-is in other R processes.
One example is R <em>connection</em>s, e.g.,</p>
<div class="example">
<p>con &lt;- file("/path/to/file", open = "wb") str(con) # ‘file’ int 3
# - attr(*, "conn_id")=&lt;externalptr&gt;</p>
</div>
<p>Any attempt to use a connection in another R process, for instance,
by saving it to file, restarting R, and loading it back in, or by
sending it to a parallel worker, will at best produce a run-time error,
and in the worst case, produce invalid results or, for instance, write
to the wrong file. These constraints apply to all types of
parallelization frameworks in R, including the future framework.</p>
<p>There are other types of objects that cannot be transferred as-is to
external processes, many from popular third-party packages, e.g.,
database connections of the <a
href="https://CRAN.R-project.org/package=DBI">DBI</a> package, XML
documents of the <a
href="https://CRAN.R-project.org/package=xml2">xml2</a> package, STAN
models of the <a href="https://CRAN.R-project.org/package=stan">stan</a>
package, and many more<a href="#fn14" class="footnote-ref" id="fnref14"
role="doc-noteref"><sup>14</sup></a>. An indicator of this is when an R
object has an <em>external pointer</em>, which is used for referencing
an internal low-level object. This suggests that the object is bound to
the current process and its lifespan. Unfortunately, it is not a
sufficient indicator because some objects with external pointers can be
exported, e.g., <a
href="https://CRAN.R-project.org/package=data.table">data.table</a>
objects. This makes it complicated to automate the detection of
non-exportable objects and protect against using them in parallel
processing. The current best practice is to be aware of these types of
objects and to document new ones when discovered, which often happens
when there is an unexpected run-time error. To help troubleshooting, it
is possible to configure the future package to scan for and warn about
globals with external pointers whenever used in a future.</p>
<p>Finally, it is theoretically possible to restructure some of the
“non-exportable” object types such that they can be used in parallel
processing. This is discussed further in the ‘Future work’ section.</p>
<h2 id="overhead">Overhead</h2>
<p>With parallel processing comes overhead. Typically, sources of added
processing time are from spawning new parallel processes, sending
instructions and globals to the workers, querying workers for results,
and receiving results (Figure <a href="#figure:future-4workers"
data-reference-type="ref"
data-reference="figure:future-4workers">1</a>). Because of this, there
is always a trade-off between sequential and parallel processing, and on
how many parallel workers can be used before the total overhead
dominates the benefits. Whether or not parallelization is beneficial,
and for which parallel backends, depends on what is being
parallelized.</p>
<p>As with other parallel solutions, in the future framework, overhead
differs between parallel backends. Certain parallel backends, such as
forked processing (“multicore”), are better suited for low-latency
requirements, whereas others, such as distributed processing (“cluster”
and “batchtools”), are better suited for large-throughput requirements.
For example, many fast operations applied to a single large data frame
should probably be parallelized on the local computer with forked
processing, if supported, rather than being distributed on a compute
cluster running in the cloud. In contrast, processing hundreds of data
files may be completed sooner if distributed out to multiple computers
(with access to the same file system), for instance, via a job
scheduler, rather than being processed in parallel on the local
machine.</p>
<p>Besides the overhead added by the parallel backend, each future,
regardless of backend, has a baseline overhead. Specifically, there is a
small overhead from the static-code inspection used to identify global
variables, from exception handling needed to capture and relay errors,
and from capturing and relaying standard output and conditions. Except
for the error-handling overhead, these can all be avoided via certain
future() arguments, e.g., by manually specifying globals needed and by
disabling the relaying of output and conditions.</p>
<p>R has several profiling tools that can help identify bottlenecks and
overhead in computational expensive tasks, e.g., system.time() of the
base package, <a
href="https://CRAN.R-project.org/package=microbenchmark">microbenchmark</a> <span
class="citation" data-cites="CRAN:microbenchmark">(<a
href="#ref-CRAN:microbenchmark" role="doc-biblioref">Mersmann
2021</a>)</span>, <a
href="https://CRAN.R-project.org/package=bench">bench</a> <span
class="citation" data-cites="CRAN:bench">(<a href="#ref-CRAN:bench"
role="doc-biblioref">Hester 2020</a>)</span>, Rprof() of the utils
package, <a
href="https://CRAN.R-project.org/package=proffer">proffer</a> <span
class="citation" data-cites="CRAN:proffer">(<a href="#ref-CRAN:proffer"
role="doc-biblioref">Landau 2021a</a>)</span>, and <a
href="https://CRAN.R-project.org/package=profvis">profvis</a> <span
class="citation" data-cites="CRAN:profvis">(<a href="#ref-CRAN:profvis"
role="doc-biblioref">Chang et al. 2020</a>)</span>. These tools can also
identify the different sources of overhead in the parallelization
framework itself, including the ones in the future ecosystem. It is on
the roadmap to make futures collect and report on some of these
benchmarks automatically in order to help developers optimize their code
and for end-users to choose a proper backend.</p>
<h1 id="results">Results</h1>
<p>The <em>Future API</em> is designed to unify parallel processing in R
at the lowest possible level. It provides a standard for building
richer, higher-level parallel frontends without having to worry about
and reimplement common, critical tasks such as identifying global
variables and packages, parallel RNG, and relaying of output and
conditions - cumbersome tasks that are often essential to parallel
processing.</p>
<p>Another advantage of the future framework is that new future backends
do not have to implement their versions of these tasks, which not only
lowers the threshold for implementing new backends, but also results in
a consistent behavior throughout the future ecosystem, something none of
the other parallel solutions provide. This benefits the developer
because they can focus on what to parallelize rather than how and where.
It also benefits the end-user, who will have more alternatives to how
and where parallelization will take place. For instance, the developer
might have local parallelization in mind during the development phase
due to their work-environment constraints, whereas the end-user might be
interested in parallelizing out to a cloud computing service. One may
say that code using futures scales far without the developer’s
attention. Moreover, code using futures for parallelization will be able
to take advantage of new backends that may be developed several years
from now.</p>
<p>Directly related to the separation of code and backends, end-users
and developers no longer need to rely on other package maintainers to
update their code to take advantage of any new types of computational
resources; updates that otherwise require adding another argument and
conditional statement. One example of this was future.batchtools’
predecessor, <a
href="https://CRAN.R-project.org/package=future.BatchJobs">future.BatchJobs</a>
(legacy, CRAN, archived), which was straightforward to implement on top
of <a
href="https://CRAN.R-project.org/package=BatchJobs">BatchJobs</a> <span
class="citation" data-cites="Bischl_etal_2015">(<a
href="#ref-Bischl_etal_2015" role="doc-biblioref">Bischl et al.
2015</a>)</span> as soon as the <em>Future API</em> was available. With
zero modifications, code that previously only parallelized on the local
computer could suddenly parallelize across thousands of cores on
high-performance compute (HPC) clusters via the job scheduler. All it
took was to change the plan().</p>
<p>Because the future ecosystem is at its core designed to give
consistent results across all sequential and parallel backends, it is
straightforward to update, or port, an existing, sequential, map-reduce
framework such that it can run in parallel. Not having to worry about
low-level parallelization code, which otherwise risks blurring the
objectives, lowers the threshold for designing and implementing new
parallel map-reduce APIs. There are several examples of how fairly
straightforward it is to implement higher-level parallel APIs on top of
the <em>Future API</em>. The future.apply package <span class="citation"
data-cites="CRAN:future.apply">(<a href="#ref-CRAN:future.apply"
role="doc-biblioref">Bengtsson 2021c</a>)</span>, implements futurized
variants of R’s apply functions found in the base package, e.g.,
future_apply() and future_lapply() are plug-in replacements for apply()
and lapply(). The furrr package <span class="citation"
data-cites="CRAN:furrr">(<a href="#ref-CRAN:furrr"
role="doc-biblioref">Vaughan and Dancho 2021</a>)</span> implements
futurized variants of the different map-reduce functions found in the <a
href="https://CRAN.R-project.org/package=purrr">purrr</a> package <span
class="citation" data-cites="CRAN:purrr">(<a href="#ref-CRAN:purrr"
role="doc-biblioref">Henry and Wickham 2020</a>)</span>, e.g.,
future_map() is as plug-in replacement for map(). The doFuture package
implements a generic foreach adaptor for
y &lt;- foreach(...) %dopar% { ... } that we can use with any future
backend. Because the <a
href="https://www.bioconductor.org/packages/release/bioc/html/BiocParallel.html">BiocParallel</a> <span
class="citation" data-cites="Bioc:BiocParallel">(<a
href="#ref-Bioc:BiocParallel" role="doc-biblioref">Morgan et al.
2021</a>)</span> package, part of the Bioconductor Project, supports
foreach as its backend, its functions such as bplapply() and bpvec() can
also parallelize using <em>any type of future backend</em> via
doFuture.</p>
<p>By lowering the barrier for implementing futurized variants of
popular map-reduce APIs, developers and end-users are allowed to stay
with their favorite coding style while still taking full advantage of
the future framework.</p>
<p>The <em>Future API</em> also addresses the lock-in-versus-portability
problem mentioned in the introduction; the risk that package developers
on Unix-like systems would only support multicore parallelization
methods because ” mclapply() just works” is significantly lower using
futures. Similarly, the most common way to parallelize code is to use
multiple cores on the local machine. Because it is less common to have
access to multiple machines, this often prevents developers from
considering any other types of parallelization, with the risk of locking
in end-users with other types of resources to only use a single machine.
Hence, the chance for a package to support multi-host parallelization,
including in the cloud and HPC environments, increases when using
futures.</p>
<p>The burden on package developers to test and validate their parallel
code is significant when using traditional parallelization frameworks,
especially when attempting to support multiple variants. In contrast,
when using futures, the cost of developing, testing, and maintaining
parallel code is lower - often not much more than maintaining sequential
code. This is possible because of the simplicity of the <em>Future
API</em> and the fact that the orchestration of futures is predominantly
done by the future package. Therefore, by implementing rigorous tests
for the future framework and the different backend packages, the need
for performing complementary tests in packages that make use of futures
is much smaller. Tests for future backend packages, as well as the
<em>Future API</em>, are provided by the future.tests package, which
lowers the risk for a backend not being sufficiently tested.</p>
<p>The built-in protection against nested parallelism by mistake, and
the agility of system settings of availableCores(), makes parallel code
that uses futures to play nicely on multi-tenant systems. It respects
all known R options and environment variables that specify, or otherwise
limit the number of parallel workers allowed. See
help("availableCores", package = "parallelly") for details. In contrast,
it is, unfortunately, very common to find parallel code that uses
parallel::detectCores() as the default number of workers in other
parallel frameworks. Defaulting to using all available cores this way
often wreak havoc on multi-tenant compute systems by overusing already
consumed CPU resources, sometimes bringing the system to a halt due to
too much context switching and memory use. Unfortunately, this often
results in a negative performance on also other users’ processes, and
system administrators have to spend time tracking down the root cause of
such poorly performing compute hosts.</p>
<h2 id="use-of-the-future-framework">Use of the future framework on CRAN
and Bioconductor</h2>
<p>The future package was released on CRAN in 2015. The uptake has grown
steadily ever since. As of November 2021, future is among the top-1.1%
most downloaded package on CRAN<a href="#fn15" class="footnote-ref"
id="fnref15" role="doc-noteref"><sup>15</sup></a>, and there are 210
packages on CRAN and Bioconductor that directly depend on it. For
map-reduce parallelization packages future.apply (top-1.3% most
downloaded) and furrr (top-1.8%), the corresponding number of packages
are 87 and 58, respectively.</p>
<p>Besides supporting these traditional parallelization methods, the
future framework is also used as an infrastructure elsewhere. For
example, the workflow package <a
href="https://CRAN.R-project.org/package=targets">targets</a> <span
class="citation" data-cites="Landau_2021">(<a href="#ref-Landau_2021"
role="doc-biblioref">Landau 2021b</a>)</span>, and its predecessor <a
href="https://CRAN.R-project.org/package=drake">drake</a> <span
class="citation" data-cites="Landau_2018">(<a href="#ref-Landau_2018"
role="doc-biblioref">Landau 2018</a>)</span>, implements “a pipeline
toolkit for reproducible computation at scale”. They work by defining
make-like targets and dependencies that can be resolved in parallel
using any type of future backend. Another prominent example is the <a
href="https://CRAN.R-project.org/package=shiny">shiny</a> package <span
class="citation" data-cites="CRAN:shiny">(<a href="#ref-CRAN:shiny"
role="doc-biblioref">Chang et al. 2021</a>)</span>, which implements
support for <em>asynchronous processing</em> in Shiny applications via
futures. Asynchronous processing helps to avoid long-running tasks from
blocking the user interface. Similarly, the <a
href="https://CRAN.R-project.org/package=plumber">plumber</a>
package <span class="citation" data-cites="CRAN:plumber">(<a
href="#ref-CRAN:plumber" role="doc-biblioref">Schloerke and Allen
2021</a>)</span>, which automatically generates and serves HTTP API from
R functions, uses futures to serve asynchronous web APIs and process
tasks in parallel.</p>
<h2 id="other-usages">Other uses of futures</h2>
<p>In <span class="citation" data-cites="HewittBaker_1977">Hewitt and
Baker (<a href="#ref-HewittBaker_1977"
role="doc-biblioref">1977</a>)</span>, the authors propose the
(EITHER ...) construct that “evaluates the expressions in parallel and
return the value of ‘the first one that finishes’.” A corresponding R
construct could be future_either(...) that evaluates R expressions
concurrently via futures and returns the value of the first resolved one
ignoring the others, e.g.,</p>
<div class="example">
<p>y &lt;- future_either( sort.int(x, method = "shell"), sort.int(x,
method = "quick"), sort.int(x, method = "radix") )</p>
</div>
<p>We may also use futures in cases that do not require parallel
processing per se. Indeed, the <em>Future API</em> strives to make no
assumptions about futures being resolved via parallel or distributed
processing. One example is where a particular expression can only be
resolved in a legacy version of R, on another operating system than
where the main R session runs, or in an environment that meet specific
requirements, e.g., large amounts of memory, fast local disks, or access
to a certain genomic database. Another example of a resource-specific
backend is the <a
href="https://CRAN.R-project.org/package=civis">civis</a> package <span
class="citation" data-cites="CRAN:civis">(<a href="#ref-CRAN:civis"
role="doc-biblioref">Miller and Ingersoll 2020</a>)</span>, which uses
futures to provide an R client for the commercial Civis Platform.</p>
<p>We can also use futures to evaluate non-trustworthy R expressions in
a sandboxed R environment that is, for instance, locked down in a
virtual machine, or in a Linux container, such as Singularity <span
class="citation" data-cites="Kurtzer2017">(<a href="#ref-Kurtzer2017"
role="doc-biblioref">Kurtzer et al. 2017</a>)</span> or Docker <span
class="citation" data-cites="Merkel2014">(<a href="#ref-Merkel2014"
role="doc-biblioref">Merkel 2014</a>)</span>, without access to the host
machine and its file system and network.</p>
<h1 id="future-work">Future work</h1>
<p>Although they are not part of the core future framework, future-based
map-reduce packages future.apply, furrr, doFuture, and the like, play an
essential role in how developers and end-users interact with futures. A
key feature of these packages is “load balancing”, which helps reduce
the overall overhead that comes from setting up futures and spawning
them on parallel workers and collecting their results. They achieve this
by partitioning the elements to iterated over into equally sized chunks,
typically so that there is one chunk per worker, which in turn results
in one future per chunk and hence one future per worker. In contrast,
without load balancing, each element is processed by one future
resulting in more overhead, especially when there are many elements to
iterate over. Each of these packages has its own implementation of load
balancing, despite often using exactly the same algorithm. If there is
an improvement or a bug fix to one, the maintainers of the others need
to update their code too. The same is true for how they orchestrate
globals and parallel RNG. To improve on this situation and to further
harmonize the behavior of futures in these packages, a new helper
package future.mapreduce that implements these common tasks will be
introduced, relieving these packages from those tasks. This will also
have the advantage of making it even easier to implement other types of
map-reduce APIs on top of futures.</p>
<p>Having said this, in a longer perspective, it might be possible to
remove the need for these future-based map-reduce APIs, which
essentially are thin wrappers ported from their counterpart map-reduce
APIs. This would require internal refactoring of the core future
framework, but it can likely be done while preserving full backward
compatibility with the current <em>Future API</em>. For clarification,
consider the following lapply() construct that evaluates slow_fcn(x) for
ten elements, each resolved via a unique <em>lazy</em> future:</p>
<div class="example">
<p>xs &lt;- 1:10 fs &lt;- lapply(xs, function(x) future( slow_fcn(x) ,
lazy = TRUE))</p>
</div>
<p>A lazy future defers the evaluation of its expression until we use
resolved() to query if it is resolved or until we use value() to collect
its value<a href="#fn16" class="footnote-ref" id="fnref16"
role="doc-noteref"><sup>16</sup></a>. Since neither has been called
above, these futures are still dormant, regardless of future backend
used. Next, assume that there are two parallel workers and imagine that
we have a function merge() to merge futures. This would allow us to
partition ten futures into only two futures, one per worker, and then
collect their values:</p>
<div class="example">
<p>f1 &lt;- merge(fs<span class="math display">\[1:5\]</span>) f2 &lt;-
merge(fs<span class="math display">\[6:10\]</span>) vs &lt;-
c(value(f1), value(f2))</p>
</div>
<p>We can simplify this further by encapsulating the above in the S3
method value() for <em>list</em>s:</p>
<div class="example">
<p>vs &lt;- value(fs)</p>
</div>
<p>We can mitigate the verbosity in the setup of futures with a helper
function or syntax sugar. More importantly, this would make it possible
to use futures in map-reduce APIs without the need for a counterpart
parallel implementation. It would also lower the threshold further for
adding a thin layer of support for futures <em>within</em> existing
map-reduce APIs, especially since the design of the future framework
keeps the added maintenance burden to a minimum.</p>
<p>A frequently requested feature is to support <em>suspending</em>
running futures, particularly when their runtimes are large. For
example, above future_either() function could benefit from a suspend()
function to terminate futures no longer needed. Since not all backends
may support this, extra care needs to be taken when introducing this
feature to the future framework. A related feature request is the
possibility to <em>restart</em> a future that failed due to, for
instance, a crashed worker or a partial power failure on a compute
cluster, e.g., restart(f). Combined with R’s condition handling
framework, higher-level APIs can then take on the role of retrying to
resolve failed futures, e.g.,
retry({ ... }, times = 3, on = "FutureError").</p>
<p>Implementing support for suspending and restarting futures will
indirectly add support for serializing futures themselves, which is only
partially supported in the current implementation. Being able to
serialize futures opens up further possibilities such as saving futures
to be processed at a later time, in another context, or transferring
them to a job queue that, in turn, distributes them to appropriate
compute resources.</p>
<p>The problem of not being able to export all types of objects as-is in
parallel processing can be a blocker. It turns out that for a subset of
these, we could use <em>marshaling</em> to encode them before
serializing them such that a working clone can be reconstructed after
unserializing and <em>unmarshaling</em>. As an example, a read-only file
connection can be marshaled by recording its filename and file position
so that the parallel worker could open its own read-only connection for
the same file at the same position. Marshaling is a rarely used concept
in R, possibly because there is no standard convention for package
developers to rely on. Ideally, such a mechanism would allow package
developers to register custom marshal() and unmarshal() methods for
their data types, making them automatically applicable in
parallelization without prior knowledge of what objects being
transferred.</p>
<p>Other than setting the backend via plan(), it is not possible to
direct a particular future to a specific backend type based on the needs
of the future. To support this, we have to add options to declare what
<em>resources</em> are needed to resolve particular future. For
instance,</p>
<div class="example">
<p>f &lt;- future( ... , resources = c("r:3.2.*", "mount:/data",
"!fork"))</p>
</div>
<p>could be one way to specify that this future has to be resolved with
R 3.2 on a machine with a /data mount point and that forked parallel
processing must not be used. Some resources may be implicit based on
exported globals, e.g., a specific file required when exporting a file
connection via marshaling.</p>
<p>All the above is on the roadmap for the future framework.</p>
<h1 id="summary">Summary</h1>
<p>The future package is a lightweight R package that provides an
alternative approach for parallel processing in R. It implements the
<em>Future API</em>, which comprises three basic functions, from which
richer, higher-level APIs for parallel processing can be constructed.
Several of these higher-level APIs mimic counterpart map-reduce APIs
closely, allowing developers to stay with their favorite coding style
for their parallel needs. The future framework is designed so that the
developer does not have to worry about common, critical tasks such as
exporting globals to workers, using proper parallel RNG, and taking care
of output, messages, warnings, and errors. This design lowers the
barriers to reimplement existing algorithms and methods in parallel
while avoiding increasing the maintenance burden. When using futures,
the end-user controls which parallel backend is used, while the
developer controls what to parallelize. This is possible because all
future backends have been validated to conform to the <em>Future
API</em> specifications, ensuring that futures produce the same results
regardless of how and where they are processed.</p>
<h1 id="acknowledgements">Acknowledgments</h1>
<p>I am grateful to all users and developers who have contributed to the
future framework with questions and answers, feature requests, bug
reports, and interesting and fruitful discussions. I am thankful to the
reviewers, the editor, and everyone else who gave comments and
suggestions helping to improve this article. The development of the
<em>Future API Specifications and Conformance</em> test suite in the
future.tests package was supported by the R Consortium through its
Infrastructure Steering Committee (ISC) grant program.</p>
<p><em>Henrik Bengtsson  Department of Epidemiology and Biostatistics, 
University of California, San Francisco  San Francisco, CA  United
States  <a
href="mailto:henrik.bengtsson@gmail.com"><code>henrik.bengtsson@gmail.com</code></a></em></p>
<h2 class="unnumbered appendix"
id="cran-task-views-implied-by-cited-packages">CRAN Task Views implied
by cited packages</h2>
<div id="refs" class="references csl-bib-body hanging-indent"
role="doc-bibliography">
<div id="ref-CRAN:doFuture" class="csl-entry" role="doc-biblioentry">
H. Bengtsson. <em>doFuture: A universal foreach parallel adapter using
the <span>Future API</span> of the ’future’ package.</em> 2021a. URL <a
href="https://CRAN.R-project.org/package=doFuture">https://CRAN.R-project.org/package=doFuture</a>.
R package version 0.12.0.
</div>
<div id="ref-CRAN:future" class="csl-entry" role="doc-biblioentry">
H. Bengtsson. <em>Future: Unified parallel and distributed processing in
<span>R</span> for everyone.</em> 2021b. URL <a
href="https://CRAN.R-project.org/package=future">https://CRAN.R-project.org/package=future</a>.
R package version 1.23.0.
</div>
<div id="ref-CRAN:future.apply" class="csl-entry"
role="doc-biblioentry">
H. Bengtsson. <em>Future.apply: Apply function to elements in parallel
using futures.</em> 2021c. URL <a
href="https://CRAN.R-project.org/package=future.apply">https://CRAN.R-project.org/package=future.apply</a>.
R package version 1.8.1.
</div>
<div id="ref-CRAN:future.batchtools" class="csl-entry"
role="doc-biblioentry">
H. Bengtsson. <em>Future.batchtools: A <span>Future API</span> for
parallel and distributed processing using ’batchtools’.</em> 2021d. URL
<a
href="https://CRAN.R-project.org/package=future.batchtools">https://CRAN.R-project.org/package=future.batchtools</a>.
R package version 0.10.0.
</div>
<div id="ref-CRAN:future.callr" class="csl-entry"
role="doc-biblioentry">
H. Bengtsson. <em>Future.callr: A <span>Future API</span> for parallel
processing using ’callr’.</em> 2021e. URL <a
href="https://CRAN.R-project.org/package=future.callr">https://CRAN.R-project.org/package=future.callr</a>.
R package version 0.6.1.
</div>
<div id="ref-CRAN:future.tests" class="csl-entry"
role="doc-biblioentry">
H. Bengtsson. <em>Future.tests: Test suite for <span>Future API</span>
backends.</em> 2021f. URL <a
href="https://CRAN.R-project.org/package=future.tests">https://CRAN.R-project.org/package=future.tests</a>.
R package version 0.3.0.
</div>
<div id="ref-CRAN:globals" class="csl-entry" role="doc-biblioentry">
H. Bengtsson. <em>Globals: Identify global objects in <span>R</span>
expressions.</em> 2020. URL <a
href="https://CRAN.R-project.org/package=globals">https://CRAN.R-project.org/package=globals</a>.
R package version 0.14.0.
</div>
<div id="ref-CRAN:listenv" class="csl-entry" role="doc-biblioentry">
H. Bengtsson. <em>Listenv: Environments behaving (almost) as lists.</em>
2019. URL <a
href="https://CRAN.R-project.org/package=listenv">https://CRAN.R-project.org/package=listenv</a>.
R package version 0.8.0.
</div>
<div id="ref-CRAN:parallelly" class="csl-entry" role="doc-biblioentry">
H. Bengtsson. <em>Parallelly: Enhancing the ’parallel’ package.</em>
2021g. URL <a
href="https://CRAN.R-project.org/package=parallelly">https://CRAN.R-project.org/package=parallelly</a>.
R package version 1.28.1.
</div>
<div id="ref-CRAN:progressr" class="csl-entry" role="doc-biblioentry">
H. Bengtsson. <em>Progressr: A inclusive, unifying <span>API</span> for
progress updates.</em> 2021h. URL <a
href="https://CRAN.R-project.org/package=progressr">https://CRAN.R-project.org/package=progressr</a>.
R package version 0.9.0.
</div>
<div id="ref-Bischl_etal_2015" class="csl-entry" role="doc-biblioentry">
B. Bischl, M. Lang, O. Mersmann, J. Rahnenführer and C. Weihs.
<span>BatchJobs</span> and <span>BatchExperiments</span>: Abstraction
mechanisms for using <span>R</span> in batch environments. <em>Journal
of Statistical Software</em>, 64(11): 1–25, 2015. URL <a
href="https://dx.doi.org/10.18637/jss.v064.i11">https://dx.doi.org/10.18637/jss.v064.i11</a>.
</div>
<div id="ref-CRAN:shiny" class="csl-entry" role="doc-biblioentry">
W. Chang, J. Cheng, J. Allaire, Y. Xie and J. McPherson. <em>Shiny: Web
application framework for <span>R</span>.</em> 2021. URL <a
href="https://CRAN.R-project.org/package=shiny">https://CRAN.R-project.org/package=shiny</a>.
R package version 1.7.1.
</div>
<div id="ref-CRAN:profvis" class="csl-entry" role="doc-biblioentry">
W. Chang, J. Luraschi and T. Mastny. <em>Profvis: Interactive
visualizations for profiling r code.</em> 2020. URL <a
href="https://CRAN.R-project.org/package=profvis">https://CRAN.R-project.org/package=profvis</a>.
R package version 0.3.7.
</div>
<div id="ref-CRAN:promises" class="csl-entry" role="doc-biblioentry">
J. Cheng. <em>Promises: Abstractions for promise-based asynchronous
programming.</em> 2021. URL <a
href="https://CRAN.R-project.org/package=promises">https://CRAN.R-project.org/package=promises</a>.
R package version 1.2.0.1.
</div>
<div id="ref-CRAN:callr" class="csl-entry" role="doc-biblioentry">
G. Csárdi and W. Chang. <em>Callr: Call <span>R</span> from
<span>R</span>.</em> 2021. URL <a
href="https://CRAN.R-project.org/package=callr">https://CRAN.R-project.org/package=callr</a>.
R package version 3.7.0.
</div>
<div id="ref-GitHub:revdepcheck" class="csl-entry"
role="doc-biblioentry">
G. Csárdi and H. Wickham. <em>Revdepcheck: Automated reverse dependency
checking.</em> 2021. URL <a
href="https://github.com/r-lib/revdepcheck\#readme">https://github.com/r-lib/revdepcheck\#readme</a>.
R package version 1.0.0.9001.
</div>
<div id="ref-DeanGhemawat2004" class="csl-entry" role="doc-biblioentry">
J. Dean and S. Ghemawat. <span>MapReduce</span>: Simplified data
processing on large clusters. In <em>OSDI’04: Sixth symposium on
operating system design and implementation</em>, pages. 137–150 2004.
San Francisco, CA. URL <a
href="https://doi.org/10.1145/1327452.1327492">https://doi.org/10.1145/1327452.1327492</a>.
</div>
<div id="ref-Eddelbuettel2020" class="csl-entry" role="doc-biblioentry">
D. Eddelbuettel. Parallel computing with <span>R</span>: A brief review.
<em>WIREs Computational Statistics</em>, 13(2): e1515, 2021. URL <a
href="https://doi.org/10.1002/wics.1515">https://doi.org/10.1002/wics.1515</a>.
</div>
<div id="ref-CRAN:digest" class="csl-entry" role="doc-biblioentry">
D. Eddelbuettel, with contributions by Antoine Lucas, J. Tuszynski, H.
Bengtsson, S. Urbanek, M. Frasca, B. Lewis, M. Stokely, H. Muehleisen,
D. Murdoch, et al. <em>Digest: Create compact hash digests of
<span>R</span> objects.</em> 2021. URL <a
href="https://CRAN.R-project.org/package=digest">https://CRAN.R-project.org/package=digest</a>.
R package version 0.6.28.
</div>
<div id="ref-CRAN:googleComputeEngineR" class="csl-entry"
role="doc-biblioentry">
M. Edmondson. <em>googleComputeEngineR: <span>R</span> interface with
<span>Google Compute Engine</span>.</em> 2019. URL <a
href="https://CRAN.R-project.org/package=googleComputeEngineR">https://CRAN.R-project.org/package=googleComputeEngineR</a>.
R package version 0.3.0.
</div>
<div id="ref-FriedmanWise_1978" class="csl-entry"
role="doc-biblioentry">
D. P. Friedman and D. S. Wise. Aspects of applicative programming for
parallel processing. <em><span>IEEE</span> Transactions on
Computers</em>, C-27(4): 289–296, 1978. URL <a
href="https://doi.org/10.1109/tc.1978.1675100">https://doi.org/10.1109/tc.1978.1675100</a>.
</div>
<div id="ref-CRAN:purrr" class="csl-entry" role="doc-biblioentry">
L. Henry and H. Wickham. <em>Purrr: Functional programming tools.</em>
2020. URL <a
href="https://CRAN.R-project.org/package=purrr">https://CRAN.R-project.org/package=purrr</a>.
R package version 0.3.4.
</div>
<div id="ref-CRAN:bench" class="csl-entry" role="doc-biblioentry">
J. Hester. <em>Bench: High precision timing of r expressions.</em> 2020.
URL <a
href="https://CRAN.R-project.org/package=bench">https://CRAN.R-project.org/package=bench</a>.
R package version 1.1.1.
</div>
<div id="ref-HewittBaker_1977" class="csl-entry" role="doc-biblioentry">
C. Hewitt and H. G. Baker. Laws for communicating parallel processes. In
<em>IFIP congress</em>, pages. 987–992 1977. URL <a
href="https://dblp.uni-trier.de/db/conf/ifip/ifip1977.html\#HewittB77">https://dblp.uni-trier.de/db/conf/ifip/ifip1977.html\#HewittB77</a>.
</div>
<div id="ref-Hibbard_1976" class="csl-entry" role="doc-biblioentry">
P. Hibbard. Parallel processing facilities. In <em>New directions in
algorithmic languages</em>, Ed S. A. Schuman 1976. IRIA.
</div>
<div id="ref-Kane_etal_2013" class="csl-entry" role="doc-biblioentry">
M. Kane, J. Emerson and S. Weston. Scalable strategies for computing
with massive data. <em>Journal of Statistical Software</em>, 55(14):
1–19, 2013. URL <a
href="https://doi.org/10.18637/jss.v055.i14">https://doi.org/10.18637/jss.v055.i14</a>.
</div>
<div id="ref-Kurtzer2017" class="csl-entry" role="doc-biblioentry">
G. M. Kurtzer, V. Sochat and M. W. Bauer. Singularity: Scientific
containers for mobility of compute. <em>PLOS One</em>, 12(5): e0177459,
2017. URL <a
href="https://doi.org/10.1371/journal.pone.0177459">https://doi.org/10.1371/journal.pone.0177459</a>.
</div>
<div id="ref-LEcuyer:1999" class="csl-entry" role="doc-biblioentry">
P. L’Ecuyer. Good parameters and implementations for combined multiple
recursive random number generators. <em>Operations Research</em>, 47(1):
159–164, 1999. URL <a
href="https://doi.org/10.1287/opre.47.1.159">https://doi.org/10.1287/opre.47.1.159</a>.
</div>
<div id="ref-CRAN:proffer" class="csl-entry" role="doc-biblioentry">
W. M. Landau. <em>Proffer: Profile r code and visualize with
’pprof’.</em> 2021a. URL <a
href="https://CRAN.R-project.org/package=proffer">https://CRAN.R-project.org/package=proffer</a>.
R package version 0.1.5.
</div>
<div id="ref-Landau_2018" class="csl-entry" role="doc-biblioentry">
W. M. Landau. The drake <span>R</span> package: A pipeline toolkit for
reproducibility and high-performance computing. <em>Journal of Open
Source Software</em>, 3(21): 2018. URL <a
href="https://doi.org/10.21105/joss.00550">https://doi.org/10.21105/joss.00550</a>.
</div>
<div id="ref-Landau_2021" class="csl-entry" role="doc-biblioentry">
W. M. Landau. The targets <span>R</span> package: A dynamic make-like
function-oriented pipeline toolkit for reproducibility and
high-performance computing. <em>Journal of Open Source Software</em>,
6(57): 2959, 2021b. URL <a
href="https://doi.org/10.21105/joss.02959">https://doi.org/10.21105/joss.02959</a>.
</div>
<div id="ref-Lang_etal_2017" class="csl-entry" role="doc-biblioentry">
M. Lang, B. Bischl and D. Surmann. Batchtools: Tools for <span>R</span>
to work on batch systems. <em>Journal of Open Source Software</em>,
2(10): 135, 2017. URL <a
href="https://doi.org/10.21105/joss.00135">https://doi.org/10.21105/joss.00135</a>.
</div>
<div id="ref-CRAN:doRedis" class="csl-entry" role="doc-biblioentry">
B. W. Lewis. <em>doRedis: ’Foreach’ parallel adapter using the ’redis’
database.</em> 2020. URL <a
href="https://CRAN.R-project.org/package=doRedis">https://CRAN.R-project.org/package=doRedis</a>.
R package version 3.0.0.
</div>
<div id="ref-CRAN:sparklyr" class="csl-entry" role="doc-biblioentry">
J. Luraschi, K. Kuo, K. Ushey, J. Allaire, H. Falaki, L. Wang, A. Zhang,
Y. Li and The Apache Software Foundation. <em>Sparklyr: R interface to
apache spark.</em> 2021. URL <a
href="https://CRAN.R-project.org/package=sparklyr">https://CRAN.R-project.org/package=sparklyr</a>.
R package version 1.7.2.
</div>
<div id="ref-Matsumoto_Nishimura:1998" class="csl-entry"
role="doc-biblioentry">
M. Matsumoto and T. Nishimura. Mersenne twister: A 623-dimensionally
equidistributed uniform pseudo-random number generator. <em>ACM
Transactions on Modeling and Computer Simulation</em>, 3–30, 1998. URL
<a
href="https://doi.org/10.1145/272991.272995">https://doi.org/10.1145/272991.272995</a>.
</div>
<div id="ref-Merkel2014" class="csl-entry" role="doc-biblioentry">
D. Merkel. Docker: Lightweight <span>Linux</span> containers for
consistent development and deployment. <em>Linux Journal</em>,
2014(239): 2, 2014.
</div>
<div id="ref-CRAN:microbenchmark" class="csl-entry"
role="doc-biblioentry">
O. Mersmann. <em>Microbenchmark: Accurate timing functions.</em> 2021.
URL <a
href="https://CRAN.R-project.org/package=microbenchmark">https://CRAN.R-project.org/package=microbenchmark</a>.
R package version 1.4-8.
</div>
<div id="ref-CRAN:doParallel" class="csl-entry" role="doc-biblioentry">
Microsoft Corporation and S. Weston. <em>doParallel: Foreach parallel
adaptor for the ’parallel’ package.</em> 2020. URL <a
href="https://CRAN.R-project.org/package=doParallel">https://CRAN.R-project.org/package=doParallel</a>.
R package version 1.0.16.
</div>
<div id="ref-CRAN:foreach" class="csl-entry" role="doc-biblioentry">
Microsoft and S. Weston. <em>Foreach: Provides foreach looping
construct.</em> 2020. URL <a
href="https://CRAN.R-project.org/package=foreach">https://CRAN.R-project.org/package=foreach</a>.
R package version 1.5.1.
</div>
<div id="ref-CRAN:civis" class="csl-entry" role="doc-biblioentry">
P. Miller and K. Ingersoll. <em>Civis: <span>R</span> client for the
’civis platform API’.</em> 2020. URL <a
href="https://CRAN.R-project.org/package=civis">https://CRAN.R-project.org/package=civis</a>.
R package version 3.0.0.
</div>
<div id="ref-Bioc:BiocParallel" class="csl-entry"
role="doc-biblioentry">
M. Morgan, V. Obenchain, M. Lang, R. Thompson and N. Turaga.
<em>BiocParallel: <span>Bioconductor</span> facilities for parallel
evaluation.</em> 2021. URL <a
href="https://bioconductor.org/packages/BiocParallel/">https://bioconductor.org/packages/BiocParallel/</a>.
R package version 1.28.0.
</div>
<div id="ref-CRAN:doMC" class="csl-entry" role="doc-biblioentry">
Revolution Analytics and S. Weston. <em>doMC: Foreach parallel adaptor
for ’parallel’.</em> 2020. URL <a
href="https://CRAN.R-project.org/package=doMC">https://CRAN.R-project.org/package=doMC</a>.
R package version 1.3.7.
</div>
<div id="ref-CRAN:plumber" class="csl-entry" role="doc-biblioentry">
B. Schloerke and J. Allen. <em>Plumber: An API generator for r.</em>
2021. URL <a
href="https://CRAN.R-project.org/package=plumber">https://CRAN.R-project.org/package=plumber</a>.
R package version 1.1.0.
</div>
<div id="ref-Schmidberger2009" class="csl-entry" role="doc-biblioentry">
M. Schmidberger, M. Morgan, D. Eddelbuettel, H. Yu, L. Tierney and U.
Mansmann. State-of-the-art in parallel computing with r. <em>Journal of
Statistical Software</em>, 47(1): 2009.
</div>
<div id="ref-Schmidt2017" class="csl-entry" role="doc-biblioentry">
D. Schmidt, W.-C. Chen, M. A. Matheson and G. Ostrouchov. <span
class="nocase">Programming with BIG data in R</span>: Scaling analytics
from one to thousands of nodes. <em>Big Data Research</em>, 8: 1–11,
2017. DOI <a
href="https://doi.org/10.1016/j.bdr.2016.10.002">https://doi.org/10.1016/j.bdr.2016.10.002</a>.
</div>
<div id="ref-CRAN:codetools" class="csl-entry" role="doc-biblioentry">
L. Tierney. <em>Codetools: Code analysis tools for <span>R</span>.</em>
2020. URL <a
href="https://CRAN.R-project.org/package=codetools">https://CRAN.R-project.org/package=codetools</a>.
R package version 0.2-18.
</div>
<div id="ref-CRAN:snow" class="csl-entry" role="doc-biblioentry">
L. Tierney, A. J. Rossini, N. Li and H. Sevcikova. <em>Snow: Simple
network of workstations.</em> 2021. URL <a
href="https://CRAN.R-project.org/package=snow">https://CRAN.R-project.org/package=snow</a>.
R package version 0.4-4.
</div>
<div id="ref-CRAN:multicore" class="csl-entry" role="doc-biblioentry">
S. Urbanek. <em>Multicore: A stub package to ease transition to
’parallel’.</em> 2014. URL <a
href="https://CRAN.R-project.org/package=multicore">https://CRAN.R-project.org/package=multicore</a>.
R package version 0.2.
</div>
<div id="ref-CRAN:furrr" class="csl-entry" role="doc-biblioentry">
D. Vaughan and M. Dancho. <em>Furrr: Apply mapping functions in parallel
using futures.</em> 2021. URL <a
href="https://CRAN.R-project.org/package=furrr">https://CRAN.R-project.org/package=furrr</a>.
R package version 0.2.3.
</div>
<div id="ref-CRAN:doMPI" class="csl-entry" role="doc-biblioentry">
S. Weston. <em>doMPI: Foreach parallel adaptor for <span>Rmpi</span>
package.</em> 2017. URL <a
href="https://CRAN.R-project.org/package=doMPI">https://CRAN.R-project.org/package=doMPI</a>.
R package version 0.2.2.
</div>
</div>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Although the concept of futures could
also apply to C, C++, and Fortran parallelization, the future framework
targets parallelization at the R level and does not provide an
implementation for native code.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>We use the term “map-reduce” as it is
used in functional programming. The <em>MapReduce</em> method by <span
class="citation" data-cites="DeanGhemawat2004">Dean and Ghemawat (<a
href="#ref-DeanGhemawat2004" role="doc-biblioref">2004</a>)</span> was
inspired by this term but they are not equivalent.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>See the foreach issue tracker at <a
href="https://github.com/RevolutionAnalytics/foreach"
class="uri">https://github.com/RevolutionAnalytics/foreach</a>.<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>We can find this future-value pattern
in several implementations for parallel processing, including the ones
we use in R. The mcparallel()- mccollect() pair of functions in parallel
is one example. This is why the future-value abstraction can be mapped
onto many of our existing parallel frameworks in a unified way.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Here, vs &lt;- lapply(fs, value) is
used for clarification but we could also have used vs &lt;- value(fs)
because value() is a generic function with implementation also for lists
and other types of containers.<a href="#fnref5" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>These solutions process each element
in a separate future, which is suboptimal if the overhead of creating a
future is relatively large compared to the evaluation time. This
overhead can be mitigated by processing elements in chunks, something
that requires more complex code than what is shown in these examples.<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>See <a
href="https://github.com/HenrikBengtsson/Wishlist-for-R/issues/55"
class="uri">https://github.com/HenrikBengtsson/Wishlist-for-R/issues/55</a><a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>The type of promises that R supports
should not be mistaken for the type of promises as defined by the <a
href="https://CRAN.R-project.org/package=promises">promises</a> <span
class="citation" data-cites="CRAN:promises">(<a
href="#ref-CRAN:promises" role="doc-biblioref">Cheng 2021</a>)</span>
package, which, together with futures, is used for asynchronous
processing in Shiny applications.<a href="#fnref8" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>The internal call to value() will
also cause any captured standard output and conditions to be relayed.<a
href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>I have dropped the curly brackets on
the RHS to make the example tidier. Just like with regular assignment,
there is nothing preventing us from using composite expressions also
with future assignments.<a href="#fnref10" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>The callr backend performs similarly
to the PSOCK-based multisession backend. However, in contrast to the
latter, it does not rely on socket connections, which on MS Windows may
require administrative rights on the machine’s firewall in order to
allow the R process to communicate on certain ports. Moreover, on
machines with a large number of cores, PSOCK clusters are limited to 125
parallel workers because that is the maximum number of connections R can
have open simultaneously.<a href="#fnref11" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>It also supports using parLapply()
functions.<a href="#fnref12" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>There is a plan to update foreach to
use the exact same static-code-analysis method as the future package use
for identifying globals. As the maintainer of the future framework, I
collaborate with the maintainer of the foreach package to implement
this.<a href="#fnref13" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>See future package vignette ’’ for
more examples.<a href="#fnref14" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>The ranks are robust estimates based
on the average median weekly download counts from the RStudio CRAN
mirror during four weeks.<a href="#fnref15" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>Although a lazy future defers the
evaluation to a later time, contrary to R’s <em>lazy evaluation</em> and
<em>promises</em>, a future records all dependent variables (“globals”)
when it is created, which means it will resolve to the same value even
if those globals change after the future was created and before it was
resolved. This also means that lazy and eager futures give the same
value.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode r distill-force-highlighting-css"><code class="sourceCode r"></code></pre></div>
<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</section>
<!--radix_placeholder_article_footer-->
<!--/radix_placeholder_article_footer-->
</div>

<div class="d-appendix">
</div>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<!--radix_placeholder_site_after_body-->
<!--/radix_placeholder_site_after_body-->
<!--radix_placeholder_appendices-->
<div class="appendix-bottom">
<h3 id="references">References</h3>
<div id="references-listing"></div>
<h3 id="reuse">Reuse</h3>
<p>Text and figures are licensed under Creative Commons Attribution <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>. The figures that have been reused from other sources don't fall under this license and can be recognized by a note in their caption: "Figure from ...".</p>
</div>
<!--/radix_placeholder_appendices-->
<!--radix_placeholder_navigation_after_body-->
<!--/radix_placeholder_navigation_after_body-->

</body>

</html>
